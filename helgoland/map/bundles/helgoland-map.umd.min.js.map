{"version":3,"sources":["ng://@helgoland/map/lib/base/map-cache.service.ts","ng://@helgoland/map/lib/base/map.module.ts","ng://@helgoland/map/lib/base/cached-map-component.ts","ng://@helgoland/map/lib/base/geosearch/geosearch.ts","ng://@helgoland/map/lib/base/geosearch/nominatim.service.ts","null","ng://@helgoland/map/lib/base/geocure/geocure-layer.ts","ng://@helgoland/map/lib/view/geometry-map-viewer/geometry-map-viewer.component.ts","ng://@helgoland/map/lib/view/module.ts","ng://@helgoland/map/lib/control/extent/extent.component.ts","ng://@helgoland/map/lib/control/geosearch/geosearch.component.ts","ng://@helgoland/map/lib/control/locate/locate.service.ts","ng://@helgoland/map/lib/control/locate/locate.component.ts","ng://@helgoland/map/lib/control/zoom/zoom.component.ts","ng://@helgoland/map/lib/control/module.ts","ng://@helgoland/map/lib/selector/map-selector.component.ts","ng://@helgoland/map/lib/selector/services/last-value-label-generator.interface.ts","ng://@helgoland/map/lib/selector/last-value-map-selector/last-value-map-selector.component.ts","ng://@helgoland/map/lib/selector/platform-map-selector/platform-map-selector.component.ts","ng://@helgoland/map/lib/selector/services/last-value-label-generator.service.ts","ng://@helgoland/map/lib/selector/station-map-selector/station-map-selector.component.ts","ng://@helgoland/map/lib/selector/trajectory-map-selector/trajectory-map-selector.component.ts","ng://@helgoland/map/lib/selector/module.ts"],"names":["MapCache","Map","prototype","getMap","id","this","mapCache","get","setMap","map","set","hasMap","has","deleteMap","delete","Injectable","COMPONENTS","NgModule","args","declarations","imports","exports","providers","CachedMapComponent","differs","EventEmitter","_differOverlayMaps","find","create","_differBaseMaps","ngOnInit","mapId","undefined","generateUUID","ngOnChanges","changes","fitBounds","updateZoomControl","ngDoCheck","diff","overlayMaps","forEachRemovedItem","e","_this","removeOverlayMap","previousValue","forEachAddedItem","addOverlayMap","currentValue","updateLayerControl","baseMaps","removeBaseMap","addBaseMap","ngOnDestroy","remove","createMap","mapOptions","zoomControlOptions","zoomControl","L.map","mapInitialized","emit","size","forEach","entry","key","s4","Math","floor","random","toString","substring","layerOptions","oldOverlayLayer","hasOwnProperty","label","layer","visible","addTo","removeLayer","L.tileLayer","attribution","oldBaseLayer","layerControl","removeControl","layerControlOptions","Object","keys","length","L.control","layers","zoom","Input","Output","GeoSearch","NominatimGeoSearchService","http","searchTerm","term","options","params","HttpParams","countrycodes","join","addressdetails","asPointGeometry","acceptLanguage","client","serviceUrl","resArray","result","returnResult","name","display_name","geometry","geojson","type","coordinates","parseFloat","lon","lat","boundingbox","bounds","address","reverse","point","res","displayName","city","cityDistrict","city_district","country","countryCode","country_code","county","houseNumber","house_number","neighbourhood","postcode","road","state","stateDistrict","state_district","suburb","HttpService","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","__extends","__","constructor","__decorate","decorators","target","desc","c","arguments","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","GeoCureGeoJSON","_super","call","tslib_1.__extends","getEvents","moveend","event","fetchData","onAdd","matchMaxZoom","showOnMaxZoom","getZoom","showOnMinZoom","loadData","getBounds","clearLayers","bboxparam","getWest","getSouth","getEast","getNorth","httpClient","url","bbox","subscribe","addData","GeoJSON","GeometryMapViewerComponent","color","weight","opacity","ngAfterViewInit","drawGeometry","showHighlight","zoomToGeometry","L.geoJSON","zoomTo","highlightGeometry","highlight","pointToLayer","feature","latlng","L.circleMarker","highlightStyle","setStyle","defaultStyle","avoidZoomToGeometry","Component","selector","template","styles","KeyValueDiffers","HelgolandMapViewModule","HelgolandMapModule","ExtentControlComponent","zoomToExtent","extent","GeosearchControlComponent","geosearch","triggerSearch","onSearchTriggered","removeOldGeometry","loading","onResultChanged","resultGeometry","error","clearSearch","LOCATION_FOUND_EVENT","LOCATED_MARKER_ID","LocateService","startLocate","on","evt","removeMarker","L.marker","title","console","locate","watch","setView","timeout","stopLocate","off","eachLayer","L.Marker","LocateControlComponent","locateService","locateUser","isToggled","ZoomControlComponent","zoomIn","zoomOut","CommonModule","FormsModule","HelgolandCoreModule","MapSelectorComponent","cd","setTimeout","drawGeometries","detectChanges","zoomToMarkerBounds","avoidZoomToSelection","fitBoundsMarkerOptions","LastValueLabelGenerator","LastValueMapSelectorComponent","apiInterface","lastValueLabelGenerator","statusIntervalResolver","Infinity","isContentLoading","lastValueSeriesIDs","createMarkersBySeriesIDs","markerFeatureGroup","featureGroup","obsList","tsObs","getSingleTimeseriesByInternalId","push","pipe","switchMap","val","createMarker","tap","addLayer","onSelected","finalizeMarkerObservables","ts","lastValuePresentation","createColorizedMarker","createLabeledMarker","forkJoin","log","invalidateSize","Observable","observer","getTimeseriesExtras","extras","coloredMarker","statusIntervals","lastValue","Date","getTime","ignoreStatusIntervalIfBeforeDuration","interval","getMatchingInterval","value","createColoredMarker","createDefaultColoredMarker","next","complete","createFilledMarker","radius","station","circleMarker","fillColor","fillOpacity","geoJSON","style","icon","createIconLabel","marker","ChangeDetectorRef","DatasetApiInterface","StatusIntervalResolverService","Mixin","HasLoadableContent","PlatformMapSelectorComponent","getPlatforms","filter","cluster","L.markerClusterGroup","animate","L.featureGroup","onNoResultsFound","LastValueLabelGeneratorService","date","moment","timestamp","fromNow","L.divIcon","className","html","uom","StationMapSelectorComponent","phenomenon","createValuedMarkers","createStationGeometries","tempFilter","expanded","getTimeseries","timeseries","obs","markerSelectorGenerator","createDefaultFilledMarker","getStations","createDefaultGeometry","ProfileTrajectoryMapSelectorComponent","selectedTimespan","clearMap","initLayer","data","from","to","createGeoJson","dataset","getDatasets","datasets","timespan","Timespan","firstValue","getData","values","timelist_1","onTimeListDetermined","profileDataEntry","L.GeoJSON","bringToFront","HelgolandMapSelectorModule","forRoot","config","ngModule","provide","useClass","lastValueLabelGeneratorService"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport * as L from 'leaflet';\n\n@Injectable()\nexport class MapCache {\n\n    private mapCache: Map<string, any> = new Map<string, any>();\n\n    public getMap(id: string): L.Map {\n        return this.mapCache.get(id);\n    }\n\n    public setMap(id: string, map: L.Map) {\n        this.mapCache.set(id, map);\n    }\n\n    public hasMap(id: string): boolean {\n        return this.mapCache.has(id);\n    }\n\n    public deleteMap(id: string): boolean {\n        return this.mapCache.delete(id);\n    }\n\n}\n","import { NgModule } from '@angular/core';\n\nimport { MapCache } from './map-cache.service';\n\nconst COMPONENTS = [\n];\n\n@NgModule({\n  declarations: [\n    COMPONENTS\n  ],\n  imports: [\n  ],\n  exports: [\n    COMPONENTS\n  ],\n  providers: [\n    MapCache\n  ]\n})\nexport class HelgolandMapModule { }\n","import {\n    DoCheck,\n    EventEmitter,\n    Input,\n    KeyValueDiffer,\n    KeyValueDiffers,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    Output,\n    SimpleChanges,\n} from '@angular/core';\nimport * as L from 'leaflet';\n\nimport { MapCache } from './map-cache.service';\nimport { LayerOptions } from './map-options';\n\nconst DEFAULT_BASE_LAYER_NAME = 'BaseLayer';\nconst DEFAULT_BASE_LAYER_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\nconst DEFAULT_BASE_LAYER_ATTRIBUTION = '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors';\n\nexport abstract class CachedMapComponent implements OnChanges, DoCheck, OnDestroy, OnInit {\n\n    /**\n     * A map with the given ID is created inside this component. This ID can be used the get the map instance over the map cache service.\n     */\n    @Input()\n    public mapId: string;\n\n    /**\n     * The corresponding leaflet map options (see: https://leafletjs.com/reference-1.3.4.html#map-option)\n     */\n    @Input()\n    public mapOptions: L.MapOptions;\n\n    /**\n     * Bounds for the map\n     */\n    @Input()\n    public fitBounds: L.LatLngBoundsExpression;\n\n    /**\n     * Map, which holds all overlay map layer (see: https://leafletjs.com/reference-1.3.4.html#layer)\n     */\n    @Input()\n    public overlayMaps: Map<string, LayerOptions>;\n\n    /**\n     * Map, which holds all base map layer (see: https://leafletjs.com/reference-1.3.4.html#layer)\n     */\n    @Input()\n    public baseMaps: Map<string, LayerOptions>;\n\n    /**\n     * Describes the the zoom options (see: https://leafletjs.com/reference-1.3.4.html#control-layers)\n     */\n    @Input()\n    public layerControlOptions: L.Control.LayersOptions;\n\n    /**\n     * Describes the the zoom control options (see: https://leafletjs.com/reference-1.3.4.html#control-zoom)\n     */\n    @Input()\n    public zoomControlOptions: L.Control.ZoomOptions;\n\n    /**\n     * Informs when initialization is done with map id.\n     */\n    @Output()\n    public mapInitialized: EventEmitter<string> = new EventEmitter();\n\n    /**\n     * The map object.\n     */\n    protected map: L.Map;\n\n    protected oldOverlayLayer: L.Control.LayersObject = {};\n    protected oldBaseLayer: L.Control.LayersObject = {};\n    protected layerControl: L.Control.Layers;\n    protected zoomControl: L.Control.Zoom;\n\n    private _overlayMaps: Map<string, LayerOptions>;\n    private _differOverlayMaps: KeyValueDiffer<string, LayerOptions>;\n    private _baseMaps: Map<string, LayerOptions>;\n    private _differBaseMaps: KeyValueDiffer<string, LayerOptions>;\n\n    constructor(\n        protected mapCache: MapCache,\n        protected differs: KeyValueDiffers\n    ) {\n        this._differOverlayMaps = this.differs.find({}).create();\n        this._differBaseMaps = this.differs.find({}).create();\n    }\n\n    public ngOnInit(): void {\n        if (this.mapId === undefined || this.mapId === null) {\n            this.mapId = this.generateUUID();\n        }\n    }\n\n    public ngOnChanges(changes: SimpleChanges): void {\n        if (this.map) {\n            if (changes.fitBounds) {\n                this.map.fitBounds(this.fitBounds);\n            }\n            if (changes.zoomControlOptions) {\n                this.updateZoomControl();\n            }\n        }\n    }\n\n    public ngDoCheck(): void {\n        if (this._differOverlayMaps) {\n            const changes = this._differOverlayMaps.diff(this.overlayMaps);\n            if (changes) {\n                changes.forEachRemovedItem((e) => this.removeOverlayMap(e.previousValue));\n                changes.forEachAddedItem((e) => this.addOverlayMap(e.currentValue));\n                this.updateLayerControl();\n            }\n        }\n        if (this._differBaseMaps) {\n            const changes = this._differBaseMaps.diff(this.baseMaps);\n            if (changes) {\n                changes.forEachRemovedItem((e) => this.removeBaseMap(e.previousValue));\n                changes.forEachAddedItem((e) => this.addBaseMap(e.currentValue));\n                this.updateLayerControl();\n            }\n        }\n    }\n\n    public ngOnDestroy(): void {\n        this.map.remove();\n        this.map = null;\n        this.mapCache.deleteMap(this.mapId);\n    }\n\n    protected createMap(): void {\n        if (!this.mapOptions || this.zoomControlOptions) { this.mapOptions = { zoomControl: false }; }\n        this.map = L.map(this.mapId, this.mapOptions);\n        this.mapCache.setMap(this.mapId, this.map);\n        this.mapInitialized.emit(this.mapId);\n        if (this.baseMaps && this.baseMaps.size > 0) {\n            this.baseMaps.forEach((entry, key) => this.addBaseMap(entry));\n        } else {\n            this.addBaseMap();\n        }\n        if (this.overlayMaps) { this.overlayMaps.forEach((entry, key) => this.addOverlayMap(entry)); }\n        this.updateZoomControl();\n        this.updateLayerControl();\n        if (this.fitBounds) {\n            this.map.fitBounds(this.fitBounds);\n        }\n    }\n\n    private generateUUID(): string {\n        function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000)\n                .toString(16)\n                .substring(1);\n        }\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    }\n\n    private addOverlayMap(layerOptions: LayerOptions) {\n        if (this.map) {\n            if (!this.oldOverlayLayer.hasOwnProperty[layerOptions.label]) {\n                this.oldOverlayLayer[layerOptions.label] = layerOptions.layer;\n                if (layerOptions.visible) { layerOptions.layer.addTo(this.map); }\n            }\n        }\n    }\n\n    private removeOverlayMap(layerOptions: LayerOptions) {\n        if (this.map && this.oldOverlayLayer.hasOwnProperty(layerOptions.label)) {\n            this.map.removeLayer(this.oldOverlayLayer[layerOptions.label]);\n            delete this.oldOverlayLayer[layerOptions.label];\n        }\n    }\n\n    private addBaseMap(layerOptions?: LayerOptions) {\n        if (this.map) {\n            if (!this.baseMaps || this.baseMaps.size === 0) {\n                layerOptions = {\n                    label: DEFAULT_BASE_LAYER_NAME,\n                    visible: true,\n                    layer: L.tileLayer(DEFAULT_BASE_LAYER_URL, {\n                        attribution: DEFAULT_BASE_LAYER_ATTRIBUTION\n                    })\n                };\n            }\n            if (!this.oldBaseLayer.hasOwnProperty[layerOptions.label]) {\n                this.oldBaseLayer[layerOptions.label] = layerOptions.layer;\n                if (layerOptions.visible) { layerOptions.layer.addTo(this.map); }\n            }\n        }\n    }\n\n    private removeBaseMap(layerOptions: LayerOptions) {\n        if (this.map && this.oldBaseLayer.hasOwnProperty(layerOptions.label)) {\n            this.map.removeLayer(this.oldBaseLayer[layerOptions.label]);\n            delete this.oldBaseLayer[layerOptions.label];\n        }\n    }\n\n    private updateLayerControl() {\n        if (this.map) {\n            if (this.layerControl) {\n                this.map.removeControl(this.layerControl);\n            }\n            if (this.layerControlOptions\n                && (Object.keys(this.oldBaseLayer).length > 1 || Object.keys(this.oldOverlayLayer).length > 0)) {\n                this.layerControl =\n                    L.control.layers(this.oldBaseLayer, this.oldOverlayLayer, this.layerControlOptions).addTo(this.map);\n            }\n        }\n    }\n\n    private updateZoomControl() {\n        if (this.zoomControl) { this.map.removeControl(this.zoomControl); }\n        if (this.zoomControlOptions) {\n            this.zoomControl = L.control.zoom(this.zoomControlOptions).addTo(this.map);\n        }\n    }\n}\n","import { Point } from 'geojson';\nimport { LatLngBoundsLiteral } from 'leaflet';\nimport { Observable } from 'rxjs/Observable';\n\nexport interface GeoSearchResult {\n    name: string;\n    geometry: GeoJSON.GeoJsonObject;\n    bounds?: LatLngBoundsLiteral;\n    address?: {\n        city?: string;\n        city_district?: string;\n        construction?: string;\n        continent?: string;\n        country?: string;\n        country_code?: string;\n        house_number?: string;\n        neighbourhood?: string;\n        postcode?: string;\n        public_building?: string;\n        road?: string;\n        state?: string;\n        suburb?: string;\n        town?: string;\n        [key: string]: string;\n    };\n}\n\nexport interface GeoSearchOptions {\n    acceptLanguage?: string;\n    addressdetails?: boolean;\n    asPointGeometry?: boolean;\n    countrycodes?: string[];\n}\n\nexport interface GeoReverseOptions {\n    acceptLanguage?: string;\n    addressdetails?: boolean;\n    zoom?: number;\n}\n\nexport interface GeoReverseResult {\n    lat: string;\n    lon: string;\n    displayName?: string;\n    address?: {\n        city: string;\n        cityDistrict: string;\n        country: string;\n        countryCode: string;\n        county: string;\n        houseNumber: string;\n        neighbourhood: string;\n        postcode: string;\n        road: string;\n        state: string;\n        stateDistrict: string;\n        suburb: string;\n    };\n    boundingbox?: string[];\n}\n\nexport abstract class GeoSearch {\n\n    public abstract searchTerm(term: string, options?: GeoSearchOptions): Observable<GeoSearchResult>;\n\n    public abstract reverse(point: Point, options?: GeoReverseOptions): Observable<GeoReverseResult>;\n\n}\n","import 'rxjs/add/operator/map';\n\nimport { HttpParams } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { HttpService } from '@helgoland/core';\nimport { Point } from 'geojson';\nimport { Observable } from 'rxjs/Observable';\n\nimport { GeoReverseOptions, GeoReverseResult, GeoSearch, GeoSearchOptions, GeoSearchResult } from './geosearch';\n\ninterface NominatimSearchResult {\n    display_name: string;\n    geojson?: GeoJSON.GeoJsonObject;\n    lat: string;\n    lon: string;\n    boundingbox: number[];\n    address?: {\n        city?: string;\n        city_district?: string;\n        construction?: string;\n        continent?: string;\n        country?: string;\n        country_code?: string;\n        house_number?: string;\n        neighbourhood?: string;\n        postcode?: string;\n        public_building?: string;\n        state?: string;\n        suburb?: string;\n    };\n}\n\ninterface Address {\n    address29: string;\n    house_number: string;\n    road: string;\n    neighbourhood: string;\n    suburb: string;\n    city_district: string;\n    city: string;\n    county: string;\n    state_district: string;\n    state: string;\n    postcode: string;\n    country: string;\n    country_code: string;\n}\n\ninterface NominatimReverseResult {\n    place_id: string;\n    licence: string;\n    osm_type: string;\n    osm_id: string;\n    lat: string;\n    lon: string;\n    display_name: string;\n    address: Address;\n    boundingbox: string[];\n}\n\n@Injectable()\nexport class NominatimGeoSearchService implements GeoSearch {\n\n    protected serviceUrl = 'https://nominatim.openstreetmap.org/';\n\n    constructor(\n        protected http: HttpService\n    ) { }\n\n    public searchTerm(term: string, options: GeoSearchOptions = {}): Observable<GeoSearchResult> {\n        let params = new HttpParams();\n        params = params.set('q', term);\n        params = params.set('format', 'json');\n        params = params.set('limit', '1');\n        if (options.countrycodes) { params = params.set('countrycodes', options.countrycodes.join(',')); }\n        if (options.addressdetails !== null) { params = params.set('addressdetails', options.addressdetails ? '1' : '0'); }\n        if (options.asPointGeometry !== null) { params = params.set('polygon_geojson', options.asPointGeometry ? '0' : '1'); }\n        if (options.acceptLanguage) { params = params.set('accept-language', options.acceptLanguage); }\n        return this.http.client().get(\n            this.serviceUrl + 'search',\n            { params }\n        ).map((resArray: NominatimSearchResult[]) => {\n            if (resArray.length === 1) {\n                const result = resArray[0];\n                const name = result.display_name;\n                let geometry;\n                if (result.geojson) {\n                    geometry = result.geojson;\n                } else {\n                    geometry = {\n                        type: 'Point',\n                        coordinates: [parseFloat(result.lon), parseFloat(result.lat)]\n                    };\n                }\n                const returnResult: GeoSearchResult = { name, geometry };\n                if (result.boundingbox) {\n                    returnResult.bounds = [\n                        [\n                            result.boundingbox[0],\n                            result.boundingbox[2]\n                        ],\n                        [\n                            result.boundingbox[1],\n                            result.boundingbox[3]\n                        ]\n                    ];\n                }\n                if (result.address) { returnResult.address = result.address; }\n                return returnResult;\n            }\n        });\n    }\n\n    public reverse(point: Point, options: GeoReverseOptions = {}): Observable<GeoReverseResult> {\n        let params = new HttpParams();\n        params = params.set('lat', point.coordinates[0].toString());\n        params = params.set('lon', point.coordinates[1].toString());\n        params = params.set('format', 'json');\n        if (options && options.addressdetails !== undefined) { params = params.set('addressdetails', options.addressdetails ? '1' : '0'); }\n        if (options.acceptLanguage !== null) { params = params.set('accept-language', options.acceptLanguage); }\n        if (options && options.zoom !== undefined) { params = params.set('zoom', `${options.zoom}`); }\n        return this.http.client().get(\n            this.serviceUrl + 'reverse',\n            { params }\n        ).map((res: NominatimReverseResult) => {\n            const result = {\n                lat: res.lat,\n                lon: res.lon,\n                displayName: res.display_name,\n                boundingbox: res.boundingbox\n            } as GeoReverseResult;\n            if (res.address) {\n                result.address = {\n                    city: res.address.city,\n                    cityDistrict: res.address.city_district,\n                    country: res.address.country,\n                    countryCode: res.address.country_code,\n                    county: res.address.county,\n                    houseNumber: res.address.house_number,\n                    neighbourhood: res.address.neighbourhood,\n                    postcode: res.address.postcode,\n                    road: res.address.road,\n                    state: res.address.state,\n                    stateDistrict: res.address.state_district,\n                    suburb: res.address.suburb\n                };\n            }\n            return result;\n        });\n    }\n\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { HttpClient } from '@angular/common/http';\nimport { GeoJSON, GeoJSONOptions, LatLngBounds, LeafletEvent } from 'leaflet';\n\nexport interface GeoCureGeoJSONOptions extends GeoJSONOptions {\n    url: string;\n    httpClient: HttpClient;\n    showOnMinZoom?: number;\n    showOnMaxZoom?: number;\n}\n\nexport class GeoCureGeoJSON extends GeoJSON {\n\n    public options: GeoCureGeoJSONOptions;\n\n    constructor(\n        options?: GeoCureGeoJSONOptions\n    ) {\n        super();\n        if (options) {\n            this.options = options;\n        }\n    }\n\n    public getEvents() {\n        const events = {\n            moveend: (event: LeafletEvent) => this.fetchData(event.target)\n        };\n        return events;\n    }\n\n    public onAdd(map: L.Map): this  {\n        super.onAdd(map);\n        this.fetchData(map);\n        return this;\n    }\n\n    private fetchData(map: L.Map) {\n        const matchMaxZoom = this.options.showOnMaxZoom ? map.getZoom() <= this.options.showOnMaxZoom : true;\n        const matchMinZoom = this.options.showOnMinZoom ? map.getZoom() >= this.options.showOnMinZoom : true;\n        if (matchMinZoom && matchMaxZoom) {\n            this.loadData(map.getBounds());\n        } else {\n            this.clearLayers();\n        }\n    }\n\n    private loadData(bounds: LatLngBounds) {\n        const bboxparam = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()].join(',');\n        this.options.httpClient\n            .get<GeoJSON.FeatureCollection<GeoJSON.GeometryObject>>(this.options.url, {\n                params: {\n                    bbox: bboxparam\n                }\n            })\n            .subscribe((geojson) => {\n                this.clearLayers();\n                this.addData(geojson);\n            });\n    }\n}\n","import { AfterViewInit, Component, Input, KeyValueDiffers, OnChanges, SimpleChanges } from '@angular/core';\nimport * as L from 'leaflet';\n\nimport { CachedMapComponent } from '../../base/cached-map-component';\nimport { MapCache } from '../../base/map-cache.service';\n\n@Component({\n    selector: 'n52-geometry-map-viewer',\n    template: `<div [attr.id]=\"mapId\" class=\"map-viewer\"></div>\n`,\n    styles: [`:host{height:100%;width:100%}:host .map-viewer{height:100%;width:100%}`]\n})\nexport class GeometryMapViewerComponent extends CachedMapComponent implements AfterViewInit, OnChanges {\n\n    @Input()\n    public highlight: GeoJSON.GeoJsonObject;\n\n    @Input()\n    public geometry: GeoJSON.GeoJsonObject;\n\n    @Input()\n    public zoomTo: GeoJSON.GeoJsonObject;\n\n    @Input()\n    public avoidZoomToGeometry: boolean;\n\n    private highlightGeometry: L.GeoJSON;\n\n    private defaultStyle: L.PathOptions = {\n        color: 'red',\n        weight: 5,\n        opacity: 0.65\n    };\n\n    private highlightStyle: L.PathOptions = {\n        color: 'blue',\n        weight: 10,\n        opacity: 1\n    };\n\n    constructor(\n        protected mapCache: MapCache,\n        protected differs: KeyValueDiffers\n    ) {\n        super(mapCache, differs);\n    }\n\n    public ngAfterViewInit() {\n        this.createMap();\n        this.drawGeometry();\n        this.showHighlight();\n    }\n\n    public ngOnChanges(changes: SimpleChanges) {\n        super.ngOnChanges(changes);\n        if (this.map) {\n            if (changes.highlight && changes.highlight.currentValue) {\n                this.showHighlight();\n            }\n            if (changes.geometry) {\n                this.drawGeometry();\n            }\n            if (changes.zoomTo) {\n                this.zoomToGeometry();\n            }\n        }\n    }\n\n    private zoomToGeometry() {\n        const geometry = L.geoJSON(this.zoomTo);\n        this.map.fitBounds(geometry.getBounds());\n    }\n\n    private showHighlight() {\n        if (this.highlightGeometry) {\n            this.map.removeLayer(this.highlightGeometry);\n        }\n        this.highlightGeometry = L.geoJSON(this.highlight, {\n            pointToLayer: (feature, latlng) => {\n                return L.circleMarker(latlng, this.highlightStyle);\n            }\n        });\n        this.highlightGeometry.setStyle(this.highlightStyle);\n        this.highlightGeometry.addTo(this.map);\n    }\n\n    private drawGeometry() {\n        if (this.geometry) {\n            const geojson = L.geoJSON(this.geometry, {\n                pointToLayer: (feature, latlng) => {\n                    return L.circleMarker(latlng, this.defaultStyle);\n                }\n            });\n\n            geojson.setStyle(this.defaultStyle);\n            geojson.addTo(this.map);\n\n            if (!this.avoidZoomToGeometry) {\n                this.map.fitBounds(geojson.getBounds());\n            }\n        }\n    }\n}\n","import { NgModule } from '@angular/core';\n\nimport { HelgolandMapModule } from '../base/map.module';\nimport { GeometryMapViewerComponent } from './geometry-map-viewer/geometry-map-viewer.component';\n\n@NgModule({\n    declarations: [\n        GeometryMapViewerComponent\n    ],\n    imports: [\n        HelgolandMapModule\n    ],\n    exports: [\n        GeometryMapViewerComponent\n    ],\n    providers: [\n    ]\n})\nexport class HelgolandMapViewModule { }\n","import { Component, Input } from '@angular/core';\n\nimport { MapCache } from '../../base/map-cache.service';\n\n@Component({\n  selector: 'n52-extent-control',\n  template: `<div>\n  <button type=\"button\" (click)=\"zoomToExtent()\">zoom to extent</button>\n</div>\n`\n})\nexport class ExtentControlComponent {\n\n  @Input()\n  public mapId: string;\n\n  @Input()\n  public extent: L.LatLngBoundsExpression;\n\n  constructor(\n    protected mapCache: MapCache\n  ) { }\n\n  public zoomToExtent() {\n    this.mapCache.getMap(this.mapId).fitBounds(this.extent);\n  }\n\n}\n","import { Component, EventEmitter, Input, Output } from '@angular/core';\nimport * as L from 'leaflet';\n\nimport { GeoSearch, GeoSearchOptions, GeoSearchResult } from '../../base/geosearch/geosearch';\nimport { MapCache } from '../../base/map-cache.service';\n\n@Component({\n    selector: 'n52-geosearch-control',\n    template: `<div>\n  <input [(ngModel)]=\"searchTerm\" (keyup.enter)=\"triggerSearch()\">\n  <span *ngIf=\"loading\">loading...</span>\n  <button type=\"button\" class=\"btn btn-light btn-sm\" (click)=\"clearSearch()\">X</button>\n</div>\n`\n})\nexport class GeosearchControlComponent {\n\n    /**\n     * Connect map id.\n     */\n    @Input()\n    public mapId: string;\n\n    /**\n     * Additional search options.\n     */\n    @Input()\n    public options: GeoSearchOptions;\n\n    /**\n     * Returns the search result.\n     */\n    @Output()\n    public onResultChanged: EventEmitter<GeoSearchResult> = new EventEmitter();\n\n    /**\n     * Informs, when the search is triggered.\n     */\n    @Output()\n    public onSearchTriggered: EventEmitter<void> = new EventEmitter();\n\n    public result: GeoSearchResult;\n\n    public resultGeometry: L.GeoJSON;\n\n    public searchTerm: string;\n\n    public loading: boolean;\n\n    constructor(\n        protected mapCache: MapCache,\n        protected geosearch: GeoSearch\n    ) { }\n\n    public triggerSearch() {\n        this.onSearchTriggered.emit();\n        this.removeOldGeometry();\n        if (this.searchTerm) {\n            this.loading = true;\n            this.geosearch.searchTerm(this.searchTerm, this.options).subscribe(\n                (result) => {\n                    if (!result) {\n                        this.searchTerm = '';\n                        return;\n                    }\n                    this.onResultChanged.emit(result);\n                    this.result = result;\n                    if (this.mapId) {\n                        this.resultGeometry = L.geoJSON(result.geometry).addTo(this.mapCache.getMap(this.mapId));\n                        if (result.bounds) {\n                            this.mapCache.getMap(this.mapId).fitBounds(result.bounds);\n                        } else {\n                            this.mapCache.getMap(this.mapId).fitBounds(this.resultGeometry.getBounds());\n                        }\n                    }\n                },\n                (error) => this.searchTerm = 'error occurred',\n                () => { this.loading = false; }\n            );\n        }\n    }\n\n    public clearSearch() {\n        this.searchTerm = '';\n        this.onResultChanged.emit(null);\n        this.removeOldGeometry();\n    }\n\n    private removeOldGeometry() {\n        if (this.resultGeometry) {\n            this.resultGeometry.remove();\n        }\n    }\n\n}\n","import { Injectable } from '@angular/core';\nimport * as L from 'leaflet';\n\nimport { MapCache } from '../../base/map-cache.service';\n\nconst LOCATION_FOUND_EVENT = 'locationfound';\nconst LOCATION_ERROR = 'locationerror';\nconst LOCATED_MARKER_ID = 'located';\n\n@Injectable()\nexport class LocateService {\n\n  constructor(\n    protected mapCache: MapCache\n  ) { }\n\n  public startLocate(id: string) {\n    const map = this.mapCache.getMap(id);\n    map.on(LOCATION_FOUND_EVENT, (evt: L.LocationEvent) => {\n      this.removeMarker(map);\n      const marker = L.marker(evt.latlng).addTo(map);\n      marker.options.title = LOCATED_MARKER_ID;\n    });\n    map.on(LOCATION_ERROR, (error) => {\n      console.error(error);\n    });\n    map.locate({\n      watch: true,\n      setView: true,\n      timeout: 30000\n    });\n  }\n\n  public stopLocate(id: string) {\n    const map = this.mapCache.getMap(id);\n    map.stopLocate();\n    map.off(LOCATION_FOUND_EVENT);\n    this.removeMarker(map);\n  }\n\n  private removeMarker(map: L.Map) {\n    map.eachLayer((entry) => {\n      if (entry instanceof L.Marker && entry.options.title === LOCATED_MARKER_ID) {\n        map.removeLayer(entry);\n      }\n    });\n  }\n\n}\n","import { Component, Input } from '@angular/core';\n\nimport { LocateService } from './locate.service';\n\n@Component({\n    selector: 'n52-locate-control',\n    template: `<div class=\"btn-group-vertical btn-group-sm map-control\">\n  <button type=\"button\" class=\"btn btn-sm\" (click)=\"locateUser()\" [ngClass]=\"isToggled ? 'btn-primary': 'btn-light'\">\n    locate\n  </button>\n</div>\n`,\n    styles: [`:host i{width:11px}`]\n})\nexport class LocateControlComponent {\n\n    @Input()\n    public mapId: string;\n\n    public isToggled = false;\n\n    constructor(\n        protected locateService: LocateService\n    ) { }\n\n    public locateUser() {\n        this.isToggled = !this.isToggled;\n        if (this.isToggled) {\n            this.locateService.startLocate(this.mapId);\n        } else {\n            this.locateService.stopLocate(this.mapId);\n        }\n    }\n}\n","import { Component, Input } from '@angular/core';\n\nimport { MapCache } from '../../base/map-cache.service';\n\n@Component({\n  selector: 'n52-zoom-control',\n  template: `<div class=\"btn-group-vertical map-control\">\n  <button type=\"button\" class=\"btn btn-light btn-sm\" (click)=\"zoomIn()\">\n    <i class=\"fa fa-plus\" aria-hidden=\"true\"></i>\n  </button>\n  <button type=\"button\" class=\"btn btn-light btn-sm\" (click)=\"zoomOut()\">\n    <i class=\"fa fa-minus\" aria-hidden=\"true\"></i>\n  </button>\n</div>\n`\n})\nexport class ZoomControlComponent {\n\n  @Input()\n  public mapId: string;\n\n  constructor(\n    protected mapCache: MapCache\n  ) { }\n\n  public zoomIn() {\n    this.mapCache.getMap(this.mapId).zoomIn();\n  }\n\n  public zoomOut() {\n    this.mapCache.getMap(this.mapId).zoomOut();\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HelgolandCoreModule } from '@helgoland/core';\n\nimport { HelgolandMapModule } from '../base/map.module';\nimport { ExtentControlComponent } from './extent/extent.component';\nimport { GeosearchControlComponent } from './geosearch/geosearch.component';\nimport { LocateControlComponent } from './locate/locate.component';\nimport { LocateService } from './locate/locate.service';\nimport { ZoomControlComponent } from './zoom/zoom.component';\n\nconst COMPONENTS = [\n  LocateControlComponent,\n  ZoomControlComponent,\n  GeosearchControlComponent,\n  ExtentControlComponent\n];\n\n@NgModule({\n  declarations: [\n    COMPONENTS\n  ],\n  imports: [\n    CommonModule,\n    FormsModule,\n    HelgolandCoreModule,\n    HelgolandMapModule\n  ],\n  exports: [\n    COMPONENTS\n  ],\n  providers: [\n    LocateService\n  ]\n})\nexport class HelgolandMapControlModule { }\n","import {\n    AfterViewInit,\n    ChangeDetectorRef,\n    EventEmitter,\n    Input,\n    KeyValueDiffers,\n    OnChanges,\n    Output,\n    SimpleChanges,\n} from '@angular/core';\nimport { HasLoadableContent, ParameterFilter } from '@helgoland/core';\nimport * as L from 'leaflet';\n\nimport { CachedMapComponent } from '../base/cached-map-component';\nimport { MapCache } from '../base/map-cache.service';\nimport { MarkerSelectorGenerator } from './model/marker-selector-generator';\n\nexport abstract class MapSelectorComponent<T>\n    extends CachedMapComponent\n    implements OnChanges, AfterViewInit, HasLoadableContent {\n\n    /**\n     * @input The serviceUrl, where the selection should be loaded.\n     */\n    @Input()\n    public serviceUrl: string;\n\n    /**\n     * @input The filter which should be used, while fetching the selection.\n     */\n    @Input()\n    public filter: ParameterFilter;\n\n    @Input()\n    public avoidZoomToSelection: boolean;\n\n    @Input()\n    public markerSelectorGenerator: MarkerSelectorGenerator;\n\n    @Output()\n    public onSelected: EventEmitter<T> = new EventEmitter<T>();\n\n    @Output()\n    public onContentLoading: EventEmitter<boolean> = new EventEmitter();\n\n    /**\n     * @input Additional configuration for the marker zooming (https://leafletjs.com/reference-1.3.4.html#fitbounds-options)\n     */\n    @Input()\n    public fitBoundsMarkerOptions: L.FitBoundsOptions;\n\n    public isContentLoading: (loading: boolean) => void;\n\n    @Output()\n    public onNoResultsFound: EventEmitter<boolean> = new EventEmitter();\n\n    constructor(\n        protected mapCache: MapCache,\n        protected differs: KeyValueDiffers,\n        protected cd: ChangeDetectorRef\n    ) {\n        super(mapCache, differs);\n    }\n\n    public ngAfterViewInit() {\n        this.createMap();\n        setTimeout(() => {\n            this.drawGeometries();\n            this.cd.detectChanges();\n        }, 10);\n    }\n\n    public ngOnChanges(changes: SimpleChanges) {\n        super.ngOnChanges(changes);\n        if (this.map) {\n            if (changes.serviceUrl || changes.filter || changes.cluster) {\n                this.drawGeometries();\n            }\n        }\n    }\n\n    /**\n     * Draws the geometries\n     *\n     * @protected\n     * @abstract\n     * @memberof MapSelectorComponent\n     */\n    protected abstract drawGeometries(): void;\n\n    /**\n     * Zooms to the given bounds\n     *\n     * @protected\n     * @param bounds where to zoom\n     * @memberof MapSelectorComponent\n     */\n    protected zoomToMarkerBounds(bounds: L.LatLngBoundsExpression) {\n        if (!this.avoidZoomToSelection) {\n            this.map.fitBounds(bounds, this.fitBoundsMarkerOptions || {});\n        }\n    }\n\n}\n","import { Timeseries } from '@helgoland/core';\n\nexport const enum LastValuePresentation {\n  /**\n   * colorized circle depending on status intervals\n   */\n  Colorized,\n  /**\n   * textual presentation of the last value, done with LastValueLabelGenerator\n   */\n  Textual\n}\n\nexport abstract class LastValueLabelGenerator {\n\n  /**\n   * Creates an icon label based on a given timeseries.\n   */\n  public abstract createIconLabel(ts: Timeseries);\n\n}\n","import { AfterViewInit, ChangeDetectorRef, Component, Input, KeyValueDiffers } from '@angular/core';\nimport {\n  DatasetApiInterface,\n  HasLoadableContent,\n  Mixin,\n  StatusIntervalResolverService,\n  Timeseries,\n  TimeseriesExtras,\n} from '@helgoland/core';\nimport { circleMarker, featureGroup, geoJSON, Layer, marker } from 'leaflet';\nimport { forkJoin, Observable, Observer } from 'rxjs';\nimport { switchMap, tap } from 'rxjs/operators';\n\nimport { MapCache } from '../../base/map-cache.service';\nimport { MapSelectorComponent } from '../map-selector.component';\nimport { LastValueLabelGenerator, LastValuePresentation } from '../services/last-value-label-generator.interface';\n\n/**\n * Displays selectable series with their last values on an map.\n */\n@Component({\n  selector: 'n52-last-value-map-selector',\n  template: `<div class=\"map-wrapper\" style=\"height: 100%;\">\n  <div [attr.id]=\"mapId\" class=\"map-viewer\"></div>\n</div>\n`,\n  styles: [`:host{position:relative}:host .map-viewer{width:100%;height:100%}:host .map-notifier{position:absolute;bottom:10px;left:10px;z-index:1001;width:120px;height:70px;padding:5px;opacity:.8;text-align:center}`]\n})\n@Mixin([HasLoadableContent])\nexport class LastValueMapSelectorComponent extends MapSelectorComponent<Timeseries> implements AfterViewInit {\n\n  /**\n   * The list of internal series IDs, which should be presented with their last values on the map.\n   */\n  @Input()\n  public lastValueSeriesIDs: string[];\n\n  /**\n   * Presentation type how to display the series.\n   */\n  @Input()\n  public lastValuePresentation: LastValuePresentation = LastValuePresentation.Colorized;\n\n  /**\n   * Ignores all Statusintervals where the timestamp is before a given duration in milliseconds and draws instead the default marker.\n   */\n  @Input()\n  public ignoreStatusIntervalIfBeforeDuration = Infinity;\n\n  private markerFeatureGroup: L.FeatureGroup;\n\n  constructor(\n    protected mapCache: MapCache,\n    protected differs: KeyValueDiffers,\n    protected cd: ChangeDetectorRef,\n    protected apiInterface: DatasetApiInterface,\n    protected lastValueLabelGenerator: LastValueLabelGenerator,\n    protected statusIntervalResolver: StatusIntervalResolverService\n  ) {\n    super(mapCache, differs, cd);\n  }\n\n  protected drawGeometries(): void {\n    this.isContentLoading(true);\n    if (this.lastValueSeriesIDs && this.lastValueSeriesIDs.length) {\n      this.createMarkersBySeriesIDs();\n    }\n  }\n\n  private createMarkersBySeriesIDs() {\n    this.markerFeatureGroup = featureGroup();\n    const obsList: Array<Observable<any>> = [];\n    this.lastValueSeriesIDs.forEach(entry => {\n      const tsObs = this.apiInterface.getSingleTimeseriesByInternalId(entry);\n      obsList.push(tsObs.pipe(switchMap(val => this.createMarker(val).pipe(tap(res => {\n        this.markerFeatureGroup.addLayer(res);\n        res.on('click', () => this.onSelected.emit(val));\n      })))));\n    });\n    this.finalizeMarkerObservables(obsList);\n  }\n\n  private createMarker(ts: Timeseries) {\n    switch (this.lastValuePresentation) {\n      case LastValuePresentation.Colorized:\n        return this.createColorizedMarker(ts);\n      case LastValuePresentation.Textual:\n        return this.createLabeledMarker(ts);\n    }\n    return this.createColorizedMarker(ts);\n  }\n\n  private finalizeMarkerObservables(obsList: Observable<any>[]) {\n    forkJoin(obsList).subscribe(() => {\n      console.log('do zoom to bounds');\n      if (this.map) {\n        const bounds = this.markerFeatureGroup.getBounds();\n        this.zoomToMarkerBounds(bounds);\n        this.map.invalidateSize();\n      }\n      this.isContentLoading(false);\n    });\n    if (this.map) {\n      this.markerFeatureGroup.addTo(this.map);\n    }\n  }\n\n  private createColorizedMarker(ts: Timeseries): Observable<Layer> {\n    return new Observable<Layer>((observer: Observer<Layer>) => {\n      this.apiInterface.getTimeseriesExtras(ts.id, ts.url).subscribe((extras: TimeseriesExtras) => {\n        let coloredMarker;\n        if (extras.statusIntervals) {\n          if ((ts.lastValue.timestamp) > new Date().getTime() - this.ignoreStatusIntervalIfBeforeDuration) {\n            const interval = this.statusIntervalResolver.getMatchingInterval(ts.lastValue.value, extras.statusIntervals);\n            if (interval) {\n              coloredMarker = this.createColoredMarker(ts, interval.color);\n            }\n          }\n        }\n        if (!coloredMarker) {\n          coloredMarker = this.createDefaultColoredMarker(ts);\n        }\n        observer.next(coloredMarker);\n        observer.complete();\n      });\n    });\n  }\n\n  private createColoredMarker(ts: Timeseries, color: string): Layer {\n    return this.createFilledMarker(ts, color, 10);\n  }\n\n  private createDefaultColoredMarker(ts: Timeseries): Layer {\n    return this.createFilledMarker(ts, '#000', 10);\n  }\n\n  private createFilledMarker(ts: Timeseries, color: string, radius: number): Layer {\n    let geometry: Layer;\n    if (ts.station.geometry.type === 'Point') {\n      const point = ts.station.geometry as GeoJSON.Point;\n      geometry = circleMarker([point.coordinates[1], point.coordinates[0]], {\n        color: '#000',\n        fillColor: color,\n        fillOpacity: 0.8,\n        radius: 10,\n        weight: 2\n      });\n    } else {\n      geometry = geoJSON(ts.station.geometry, {\n        style: (feature) => {\n          return {\n            color: '#000',\n            fillColor: color,\n            fillOpacity: 0.8,\n            weight: 2\n          };\n        }\n      });\n    }\n    if (geometry) {\n      geometry.on('click', () => this.onSelected.emit(ts));\n      return geometry;\n    }\n  }\n\n  private createLabeledMarker(ts: Timeseries): Observable<Layer> {\n    return new Observable<Layer>(observer => {\n      const icon = this.lastValueLabelGenerator.createIconLabel(ts);\n      if (ts.station.geometry.type === 'Point') {\n        const point = ts.station.geometry as GeoJSON.Point;\n        observer.next(marker([point.coordinates[1], point.coordinates[0]], { icon }));\n        observer.complete();\n      }\n    });\n  }\n\n}\n","import 'leaflet.markercluster';\n\nimport { AfterViewInit, ChangeDetectorRef, Component, Input, KeyValueDiffers, OnChanges } from '@angular/core';\nimport { DatasetApiInterface, HasLoadableContent, Mixin, Platform } from '@helgoland/core';\nimport * as L from 'leaflet';\n\nimport { MapCache } from '../../base/map-cache.service';\nimport { MapSelectorComponent } from '../map-selector.component';\n\n@Component({\n    selector: 'n52-platform-map-selector',\n    template: `<div class=\"map-wrapper\" style=\"height: 100%;\">\n  <div [attr.id]=\"mapId\" class=\"map-viewer\"></div>\n</div>\n`,\n    styles: [`:host{position:relative}:host .map-viewer{width:100%;height:100%}:host .map-notifier{position:absolute;bottom:10px;left:10px;z-index:1001;width:120px;height:70px;padding:5px;opacity:.8;text-align:center}`]\n})\n@Mixin([HasLoadableContent])\nexport class PlatformMapSelectorComponent extends MapSelectorComponent<Platform> implements OnChanges, AfterViewInit {\n\n    @Input()\n    public cluster: boolean;\n\n    private markerFeatureGroup: L.FeatureGroup;\n\n    constructor(\n        protected apiInterface: DatasetApiInterface,\n        protected mapCache: MapCache,\n        protected cd: ChangeDetectorRef,\n        protected differs: KeyValueDiffers\n    ) {\n        super(mapCache, differs, cd);\n    }\n\n    protected drawGeometries() {\n        this.isContentLoading(true);\n        if (this.map && this.markerFeatureGroup) { this.map.removeLayer(this.markerFeatureGroup); }\n        this.apiInterface.getPlatforms(this.serviceUrl, this.filter)\n            .subscribe((res) => {\n                if (this.map) {\n                    if (this.cluster) {\n                        this.markerFeatureGroup = L.markerClusterGroup({ animate: true });\n                    } else {\n                        this.markerFeatureGroup = L.featureGroup();\n                    }\n                    if (res instanceof Array && res.length > 0) {\n                        res.forEach((entry) => {\n                            const marker = L.marker([entry.geometry.coordinates[1], entry.geometry.coordinates[0]]);\n                            marker.on('click', () => {\n                                this.onSelected.emit(entry);\n                            });\n                            this.markerFeatureGroup.addLayer(marker);\n                        });\n                        this.markerFeatureGroup.addTo(this.map);\n                        this.zoomToMarkerBounds(this.markerFeatureGroup.getBounds());\n                    } else {\n                        this.onNoResultsFound.emit(true);\n                    }\n                    this.map.invalidateSize();\n                    this.isContentLoading(false);\n                }\n            });\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Timeseries } from '@helgoland/core';\nimport * as L from 'leaflet';\nimport moment from 'moment';\n\nimport { LastValueLabelGenerator } from './last-value-label-generator.interface';\n\n@Injectable()\nexport class LastValueLabelGeneratorService extends LastValueLabelGenerator {\n\n  constructor() {\n    super();\n  }\n\n  public createIconLabel(ts: Timeseries) {\n    const date = moment(ts.lastValue.timestamp).fromNow();\n    return L.divIcon({\n      className: 'last-value-container',\n      html: `<span class=\"last-value-label\">${ts.lastValue.value}&nbsp;${ts.uom}</span><br><span class=\"last-value-date\">${date}</span>`\n    });\n  }\n\n}\n","import 'leaflet.markercluster';\nimport 'rxjs/add/observable/forkJoin';\n\nimport {\n    AfterViewInit,\n    ChangeDetectorRef,\n    Component,\n    Input,\n    KeyValueDiffers,\n    OnChanges,\n    SimpleChanges,\n} from '@angular/core';\nimport {\n    DatasetApiInterface,\n    HasLoadableContent,\n    Mixin,\n    ParameterFilter,\n    Station,\n    StatusIntervalResolverService,\n    Timeseries,\n    TimeseriesExtras,\n} from '@helgoland/core';\nimport GeoJSON from 'geojson';\nimport * as L from 'leaflet';\nimport { Observable } from 'rxjs/Observable';\n\nimport { MapCache } from '../../base/map-cache.service';\nimport { MapSelectorComponent } from '../map-selector.component';\nimport { Layer } from 'leaflet';\nimport { forkJoin } from 'rxjs';\n\n@Component({\n    selector: 'n52-station-map-selector',\n    template: `<div class=\"map-wrapper\" style=\"height: 100%;\">\n  <div [attr.id]=\"mapId\" class=\"map-viewer\"></div>\n</div>\n`,\n    styles: [`:host{position:relative}:host .map-viewer{width:100%;height:100%}:host .map-notifier{position:absolute;bottom:10px;left:10px;z-index:1001;width:120px;height:70px;padding:5px;opacity:.8;text-align:center}`]\n})\n@Mixin([HasLoadableContent])\nexport class StationMapSelectorComponent extends MapSelectorComponent<Station> implements OnChanges, AfterViewInit {\n\n    @Input()\n    public cluster: boolean;\n\n    @Input()\n    public statusIntervals: boolean;\n\n    /**\n     * Ignores all Statusintervals where the timestamp is before a given duration in milliseconds and draws instead the default marker.\n     */\n    @Input()\n    public ignoreStatusIntervalIfBeforeDuration = Infinity;\n\n    private markerFeatureGroup: L.FeatureGroup;\n\n    constructor(\n        protected statusIntervalResolver: StatusIntervalResolverService,\n        protected apiInterface: DatasetApiInterface,\n        protected mapCache: MapCache,\n        protected differs: KeyValueDiffers,\n        protected cd: ChangeDetectorRef\n    ) {\n        super(mapCache, differs, cd);\n    }\n\n    public ngOnChanges(changes: SimpleChanges) {\n        super.ngOnChanges(changes);\n        if (this.map && changes.statusIntervals) { this.drawGeometries(); }\n    }\n\n    protected drawGeometries() {\n        this.isContentLoading(true);\n        if (this.map && this.markerFeatureGroup) { this.map.removeLayer(this.markerFeatureGroup); }\n        if (this.statusIntervals && this.filter && this.filter.phenomenon) {\n            this.createValuedMarkers();\n        } else {\n            this.createStationGeometries();\n        }\n    }\n\n    private createValuedMarkers() {\n        const tempFilter: ParameterFilter = {\n            phenomenon: this.filter.phenomenon,\n            expanded: true\n        };\n        this.apiInterface.getTimeseries(this.serviceUrl, tempFilter).subscribe((timeseries: Timeseries[]) => {\n            this.markerFeatureGroup = L.featureGroup();\n            const obsList: Array<Observable<TimeseriesExtras>> = [];\n            timeseries.forEach((ts: Timeseries) => {\n                const obs = this.apiInterface.getTimeseriesExtras(ts.id, this.serviceUrl);\n                obsList.push(obs);\n                obs.subscribe((extras: TimeseriesExtras) => {\n                    let marker;\n                    if (extras.statusIntervals) {\n                        if ((ts.lastValue.timestamp) > new Date().getTime() - this.ignoreStatusIntervalIfBeforeDuration) {\n                            const interval = this.statusIntervalResolver.getMatchingInterval(ts.lastValue.value, extras.statusIntervals);\n                            if (interval) { marker = this.createColoredMarker(ts.station, interval.color); }\n                        }\n                    }\n                    if (!marker) { marker = this.createDefaultColoredMarker(ts.station); }\n                    marker.on('click', () => {\n                        this.onSelected.emit(ts.station);\n                    });\n                    this.markerFeatureGroup.addLayer(marker);\n                });\n            });\n\n            forkJoin(obsList).subscribe(() => {\n                this.zoomToMarkerBounds(this.markerFeatureGroup.getBounds());\n                if (this.map) { this.map.invalidateSize(); }\n                this.isContentLoading(false);\n            });\n\n            if (this.map) { this.markerFeatureGroup.addTo(this.map); }\n        });\n    }\n\n    private createColoredMarker(station: Station, color: string): Layer {\n        if (this.markerSelectorGenerator.createFilledMarker) {\n            return this.markerSelectorGenerator.createFilledMarker(station, color);\n        }\n        return this.createFilledMarker(station, color, 10);\n    }\n\n    private createDefaultColoredMarker(station: Station): Layer {\n        if (this.markerSelectorGenerator.createDefaultFilledMarker) {\n            return this.markerSelectorGenerator.createDefaultFilledMarker(station);\n        }\n        return this.createFilledMarker(station, '#000', 10);\n    }\n\n    private createFilledMarker(station: Station, color: string, radius: number): Layer {\n        let geometry: Layer;\n        if (station.geometry.type === 'Point') {\n            const point = station.geometry as GeoJSON.Point;\n            geometry = L.circleMarker([point.coordinates[1], point.coordinates[0]], {\n                color: '#000',\n                fillColor: color,\n                fillOpacity: 0.8,\n                radius: 10,\n                weight: 2\n            });\n        } else {\n            geometry = L.geoJSON(station.geometry, {\n                style: (feature) => {\n                    return {\n                        color: '#000',\n                        fillColor: color,\n                        fillOpacity: 0.8,\n                        weight: 2\n                    };\n                }\n            });\n        }\n        if (geometry) {\n            geometry.on('click', () => {\n                this.onSelected.emit(station);\n            });\n            return geometry;\n        }\n    }\n\n    private createStationGeometries() {\n        this.apiInterface.getStations(this.serviceUrl, this.filter)\n            .subscribe((res) => {\n                if (this.cluster) {\n                    this.markerFeatureGroup = L.markerClusterGroup({ animate: true });\n                } else {\n                    this.markerFeatureGroup = L.featureGroup();\n                }\n                if (res instanceof Array && res.length > 0) {\n                    res.forEach((entry) => {\n                        const marker = this.createDefaultGeometry(entry);\n                        if (marker) { this.markerFeatureGroup.addLayer(marker); }\n                    });\n                    this.markerFeatureGroup.addTo(this.map);\n                    this.zoomToMarkerBounds(this.markerFeatureGroup.getBounds());\n                } else {\n                    this.onNoResultsFound.emit(true);\n                }\n                this.map.invalidateSize();\n                this.isContentLoading(false);\n            });\n    }\n\n    private createDefaultGeometry(station: Station): Layer {\n        if (this.markerSelectorGenerator && this.markerSelectorGenerator.createDefaultGeometry) {\n            return this.markerSelectorGenerator.createDefaultGeometry(station);\n        }\n        if (station.geometry) {\n            const geometry = L.geoJSON(station.geometry);\n            geometry.on('click', () => this.onSelected.emit(station));\n            return geometry;\n        } else {\n            console.error(station.id + ' has no geometry');\n        }\n    }\n}\n","import 'leaflet.markercluster';\n\nimport {\n    AfterViewInit,\n    ChangeDetectorRef,\n    Component,\n    EventEmitter,\n    Input,\n    KeyValueDiffers,\n    OnChanges,\n    Output,\n    SimpleChanges,\n} from '@angular/core';\nimport {\n    DatasetApiInterface,\n    HasLoadableContent,\n    IDataset,\n    LocatedProfileDataEntry,\n    Mixin,\n    Timespan,\n} from '@helgoland/core';\nimport * as L from 'leaflet';\n\nimport { MapCache } from '../../base/map-cache.service';\nimport { MapSelectorComponent } from '../map-selector.component';\nimport { TrajectoryResult } from '../model/trajectory-result';\n\n@Component({\n    selector: 'n52-profile-trajectory-map-selector',\n    template: `<div class=\"map-wrapper\" style=\"height: 100%;\">\n  <div [attr.id]=\"mapId\" class=\"map-viewer\"></div>\n</div>\n`,\n    styles: [`:host{position:relative}:host .map-viewer{width:100%;height:100%}:host .map-notifier{position:absolute;bottom:10px;left:10px;z-index:1001;width:120px;height:70px;padding:5px;opacity:.8;text-align:center}`]\n})\n@Mixin([HasLoadableContent])\nexport class ProfileTrajectoryMapSelectorComponent\n    extends MapSelectorComponent<TrajectoryResult>\n    implements OnChanges, AfterViewInit {\n\n    @Input()\n    public selectedTimespan: Timespan;\n\n    @Output()\n    public onTimeListDetermined: EventEmitter<number[]> = new EventEmitter();\n\n    private layer: L.FeatureGroup;\n    private data: LocatedProfileDataEntry[];\n    private dataset: IDataset;\n\n    private defaultStyle: L.PathOptions = {\n        color: 'red',\n        weight: 5,\n        opacity: 0.65\n    };\n\n    private highlightStyle: L.PathOptions = {\n        color: 'blue',\n        weight: 7,\n        opacity: 1\n    };\n\n    constructor(\n        protected apiInterface: DatasetApiInterface,\n        protected mapCache: MapCache,\n        protected differs: KeyValueDiffers,\n        protected cd: ChangeDetectorRef\n    ) {\n        super(mapCache, differs, cd);\n    }\n\n    public ngOnChanges(changes: SimpleChanges) {\n        super.ngOnChanges(changes);\n        if (changes.selectedTimespan && this.selectedTimespan && this.map) {\n            this.clearMap();\n            this.initLayer();\n            this.data.forEach((entry) => {\n                if (this.selectedTimespan.from <= entry.timestamp && entry.timestamp <= this.selectedTimespan.to) {\n                    this.layer.addLayer(this.createGeoJson(entry, this.dataset));\n                }\n            });\n            this.layer.addTo(this.map);\n        }\n    }\n\n    protected drawGeometries() {\n        this.isContentLoading(true);\n        this.apiInterface.getDatasets(this.serviceUrl, this.filter).subscribe((datasets) => {\n            datasets.forEach((dataset) => {\n                this.dataset = dataset;\n                const timespan = new Timespan(dataset.firstValue.timestamp, dataset.lastValue.timestamp);\n                this.apiInterface.getData<LocatedProfileDataEntry>(dataset.id, this.serviceUrl, timespan)\n                    .subscribe((data) => {\n                        if (this.map && data.values instanceof Array) {\n                            this.initLayer();\n                            this.data = [];\n                            const timelist: number[] = [];\n                            data.values.forEach((entry) => {\n                                this.data.push(entry);\n                                const geojson = this.createGeoJson(entry, dataset);\n                                timelist.push(entry.timestamp);\n                                this.layer.addLayer(geojson);\n                            });\n                            this.onTimeListDetermined.emit(timelist);\n                            this.layer.addTo(this.map);\n                            this.zoomToMarkerBounds(this.layer.getBounds());\n                        }\n                        this.isContentLoading(false);\n                    });\n            });\n        });\n    }\n\n    private initLayer() {\n        this.layer = L.markerClusterGroup({ animate: false });\n    }\n\n    private clearMap() {\n        if (this.map && this.layer) {\n            this.map.removeLayer(this.layer);\n        }\n    }\n\n    private createGeoJson(profileDataEntry: LocatedProfileDataEntry, dataset: IDataset): L.GeoJSON {\n        const geojson = new L.GeoJSON(profileDataEntry.geometry);\n        geojson.setStyle(this.defaultStyle);\n        geojson.on('click', () => {\n            this.onSelected.emit({\n                dataset,\n                data: profileDataEntry\n            });\n        });\n        geojson.on('mouseover', () => {\n            geojson.setStyle(this.highlightStyle);\n            geojson.bringToFront();\n        });\n        geojson.on('mouseout', () => {\n            geojson.setStyle(this.defaultStyle);\n        });\n        return geojson;\n    }\n}\n","import { CommonModule } from '@angular/common';\nimport { ModuleWithProviders, NgModule, Type } from '@angular/core';\nimport { HelgolandCoreModule } from '@helgoland/core';\n\nimport { HelgolandMapModule } from '../base/map.module';\nimport { LastValueMapSelectorComponent } from './last-value-map-selector/last-value-map-selector.component';\nimport { PlatformMapSelectorComponent } from './platform-map-selector/platform-map-selector.component';\nimport { LastValueLabelGenerator } from './services/last-value-label-generator.interface';\nimport { LastValueLabelGeneratorService } from './services/last-value-label-generator.service';\nimport { StationMapSelectorComponent } from './station-map-selector/station-map-selector.component';\nimport { ProfileTrajectoryMapSelectorComponent } from './trajectory-map-selector/trajectory-map-selector.component';\n\nconst COMPONENTS = [\n    PlatformMapSelectorComponent,\n    StationMapSelectorComponent,\n    ProfileTrajectoryMapSelectorComponent,\n    LastValueMapSelectorComponent\n];\n\nexport interface HelgolandMapSelectorModuleConfig {\n    lastValueLabelGeneratorService: Type<LastValueLabelGenerator>;\n}\n\n@NgModule({\n    declarations: [\n        COMPONENTS\n    ],\n    imports: [\n        CommonModule,\n        HelgolandCoreModule,\n        HelgolandMapModule\n    ],\n    exports: [\n        COMPONENTS\n    ],\n    providers: [\n        { provide: LastValueLabelGenerator, useClass: LastValueLabelGeneratorService }\n    ]\n})\nexport class HelgolandMapSelectorModule {\n    static forRoot(config?: HelgolandMapSelectorModuleConfig): ModuleWithProviders {\n        return {\n            ngModule: HelgolandMapSelectorModule,\n            providers: [\n                { provide: LastValueLabelGenerator, useClass: config && config.lastValueLabelGeneratorService || LastValueLabelGeneratorService }\n            ]\n        };\n    }\n}\n"]}