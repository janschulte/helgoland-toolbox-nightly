{"version":3,"sources":["null","ng://@helgoland/d3/lib/d3-overview-timeseries-graph/d3-overview-timeseries-graph.component.ts","ng://@helgoland/d3/lib/helper/d3-time-format-locale.service.ts","ng://@helgoland/d3/lib/model/d3-plot-options.ts","ng://@helgoland/d3/lib/d3-timeseries-graph/d3-timeseries-graph.component.ts","ng://@helgoland/d3/lib/model/d3-axis-type.ts","ng://@helgoland/d3/lib/d3-trajectory-graph/d3-trajectory-graph.component.ts","ng://@helgoland/d3/lib/extended-data-d3-timeseries-graph/extended-data-d3-timeseries-graph.component.ts","ng://@helgoland/d3/lib/d3-general-graph/d3-general-graph.component.ts","ng://@helgoland/d3/lib/d3.module.ts","ng://@helgoland/d3/lib/model/d3-selection-range.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","D3OverviewTimeseriesGraphComponent","timeSrvc","cd","EventEmitter","presenterOptions","overview","ngAfterViewInit","rangefactor","calculateOverviewRange","init","detectChanges","ngOnChanges","changes","ngOnDestroy","detach","timeSpanChanged","timespan","onTimespanChanged","emit","onGraphLoading","loading","isContentLoading","createTimespanOfInterval","timeInterval","overviewTimespan","getBufferedTimespan","Component","args","selector","template","styles","Time","ChangeDetectorRef","Input","Output","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__decorate","Mixin","HasLoadableContent","metadataKey","metadataValue","metadata","D3TimeFormatLocaleService","translateService","Map","addTimeFormatLocale","localeCode","definition","timeFormatLocaleMapper","set","getTimeLocale","specifier","langCode","currentLang","has","timeFormatLocale","get","format","timeFormat","Injectable","providedIn","TranslateService","none","line","point","D3TimeseriesGraphComponent","iterableDiffers","api","datasetIdResolver","timeFormatLocaleService","colorService","_this","_super","call","top","right","bottom","left","default","hover","click","showReferenceValues","generalizeAllways","togglePanZoom","hoverable","hoverStyle","HoveringStyle","grid","yaxis","showTimeLabel","requestBeforeAfterValues","coords","d3.mouse","background","node","labelTimestamp","labelXCoord","distLabelXCoord","preparedData","forEach","entry","entryIdx","idx","getItemForX","bufferSum","data","showDiagramIndicator","outputIds","highlightOutput","ids","push","focusG","style","last_1","visible_1","first_1","labelArray","textRectArray","d3.selectAll","nodes","sort","a","parseFloat","d3.select","attr","el","f","ycoord","offset","Math","max","onHighlightChanged","hideDiagramIndicator","draggingMove","dragMoveStart","d3.event","x","dragMoveRange","xAxisRange","from","to","diff","ratioTimestampDiagCoord","width","newTimeMin","newTimeMax","xAxisRangePan","plotGraph","changeTime","dragging","dragStart","xAxisRangeOrigin","drawDragRectangle","xDomainRange","dragCurrent","getxDomain","resetDrag","xCoordMouse","item","undefined","yDiagCoord","chVisLabel","xMouseAndBuffer","labelBuffer","showLabelValues","showTimeIndicatorLabel","xDiagCoord","getBBox","abs","tslib_1.__extends","currentTimeId","uuidv4","rawSvg","d3Elem","nativeElement","append","graph","margin","maxLabelwidth","graphFocus","mousedownBrush","onLanguageChanged","langChangeEvent","reloadDataForDatasets","datasetIds","id","datasetMap","loadDatasetData","addDataset","url","getSingleTimeseries","subscribe","timeseries","loadAddedDataset","error","getDataset","dataset","removeDataset","internalId","dataYranges","delete","spliceIdx","findIndex","splice","yRangesEachUom","processData","setSelectedId","tsData","find","e","selected","lines","lineWidth","addLineWidth","pointRadius","bars","axisOptions","separateYAxis","plotOptions","groupYaxis","checkYselector","uom","yAxisSelect","clicked","identifier_1","existingUom","removeSelectedId","identifier","filter","presenterOptionsChanged","options","oldGroupYaxis","assign","datasetOptionsChanged","firstChange","timeIntervalChanges","onResize","centerTime","timestamp","centeredTimespan","centerTimespan","Date","Timespan","force","datasetOptions","loadingCounter","onContentLoading","Timeseries","buffer","getTsData","expanded","generalize","forceUpdate","result","prepareTsData","onError","onCompleteLoadingData","valueBeforeTimespan","values","unshift","valueAfterTimespan","datasetIdx","color","getColor","dataEntry","visible","map","value","points","fillColor","label","zeroBased","zeroBasedYAxis","yAxisRange","autoRangeSelection","parameters","feature","phenomenon","offering","separationIdx","listOfSeparation","selectedDatasetIds","indexOf","counted","countGroupedDatasets","addReferenceValueData","startsWith","refValue","refDataEntry","referenceValues","calculatedRange","calculatedPreRange","calculatedOriginRange","predefinedRange","min","autoDataExtent","dataExtent","d3.extent","setDataExtent","extendRange","newDatasetIdx","outOfrange","autoRange","isFinite","range","preRange","originRange","yRange","yrangeObj","checkCurrentLatest","takeLatest","obj","pos","isNaN","calculateHeight","clientHeight","calculateWidth","baseVal","getyAxisRange","rangeObj","listOfUoms","changeYselection","height","selectAll","remove","yScaleBase","yAxisArray","sepId","newEl","deleteId","first","yAxisResult","drawYaxis","yScale","drawXaxis","drawAllGraphLines","addTimespanJumpButtons","interval","getXDomainByTimestamp","overviewTimespanInterval","brush","d3.brushX","extent","on","timeByCoord","getTimestampByCoord","selection","move","createLineHovering","d3.zoom","zoomStartHandler","zoomHandler","zoomEndHandler","d3.drag","panStartHandler","panMoveHandler","panEndHandler","createCopyrightLabel","createPointHovering","graphBody","enter","y","mouseOverPointHovering","mouseOutPointHovering","clickDataPoint","mousemoveHandler","mouseoutHandler","highlightFocus","focusLabelRect","focusLabel","focuslabelTime","console","log","apiurl_1","resolveInternalId","timespan_1","getTimeseries","tsArray","ts","getTimeseriesData","onClickDataPoint","dataVisible","formerTimestamp","laterTimestamp","g","buttonWidth","copyright","getDimensions","copyrightLabel","text","positionX","w","positionY","h","yTransform","xTransform","highlightRect","highlightText","drawGraphLine","minOverviewTimeInterval","maxOverviewTimeInterval","minDiagramTimestamp","mainTimeInterval","maxDiagramTimestamp","divOverviewTimeWidth","minCalcBrush","maxCalcBrush","diagramWidth","diffOverviewTimeInterval","bufferXrange","xScaleBase","d3.scaleTime","domain","xAxis","d3.axisBottom","tickFormat","date","valueOf","d3.timeSecond","d3.timeMinute","d3.timeHour","d3.timeDay","d3.timeMonth","d3.timeWeek","d3.timeYear","tickSize","d3.axisTop","ticks","entryElem","showAxis","yMin","yMax","rangeOffset","d3.scaleLinear","yAxisGen","d3.axisLeft","axis","wrapText","axisWidth","axisWidthDiv","textOff","textWidth","textHeight","textPosition","startOfPoints_1","axisradius_1","pointOffset_1","entryID","dataentry","id_1","axisDiv","opac","k","entryArray","highlightLine","groupList","this_2","el_2","dataEl","selectionID","currentUom","groupedDatasets","this_1","el_1","newSelector","arrayUomCount","ds","changeFalse","changeTrue","ID","change","changeSelectedIds","toHighlightDataset","onDatasetSelected","getYaxisRange","querySelectorClip","createLine","datum","d3.line","defined","curve","d3.curveLinear","rectBack","dotLabel","moment","onLeftSide","rectX","rectY","rectW","rectH","dotRectangle","labelX","labelY","start","end","domMin","domMax","tmp","domMinArr","domMaxArr","lowestMin","Number","POSITIVE_INFINITY","lowestMax","elem","index","array","j","x1","x2","dragRect","dragRectG","invert","bisectDate","d3.bisector","checkLeftSide","entryX","mouseCoord","d3.min","idxOfMin","classed","itemCoord","textObj","xposition","each","u","word","words","split","reverse","lineHeight","dy","tspan","pop","join","getComputedTextLength","dimensions","s4","floor","random","toString","substring","encapsulation","ViewEncapsulation","None","IterableDiffers","DatasetApiInterface","InternalIdHandler","ColorService","ViewChild","DatasetPresenterComponent","Distance","Ticks","D3TrajectoryGraphComponent","axisType","D3AxisType","dotted","getXValue","baseValues","mouse","onHoverHighlight","tick","onSelectionChangedFinished","prepareRange","dataLength","showBottomIndicatorLabel","defaultGraphOptions","processAllData","drawLineGraph","select","lineFun","calcXValue","calcYValue","curveLinear","area","y0","y1","loadData","Error","option","getData","processDataForId","datasetEntry","firstEntry_1","previous_1","createDataEntry","previous","dist","newdist","distanceBetween","geometry","coordinates","round","_a","latitude1","longitude1","latitude2","longitude2","rad","PI","lat1","lat2","sinDLat","sin","sinDLon","cos","atan2","sqrt","drawDots","drawValueLine","drawGraph","drawOptions","axisResult","drawYAxis","axisRight","drawXAxis","dragStartHandler","dragHandler","dragEndHandler","focuslabelY","onSelectionChanged","bisector","scaleLinear","axisLeft","textOffset","getXDomain","xAxisGen","axisBottom","axisTop","getXAxisLabel","ExtendedDataD3TimeseriesGraphComponent","additionalData","clearAdditionalData","prepareAdditionalData","setTimeout","additionalPreparedData","linkedDatasetId","yaxisLabel","prepDataIdx","existingAxisIndex","axisRange","warn","D3GeneralGraphComponent","xlabel","ylabel","prepareData","generalD3Input","currentValue","data_1","datasets","concat","generalData","xRange","getRange","xScale","createHoveringNet","yRangeOffset","yAxis","yAxisLabel","xRangeOffset","graphLine","xCoord","yCoord","inputData","series","vertices","d3.merge","cl","lineIndex","pointIndex","verticesFiltered","diffVoronoi2","d3.voronoi","polygons","wrap","pointPaths","exit","datasetxCoordSplit","calcDistanceHovering","radius","mX","mY","pX","pY","pow","d3.values","HelgolandD3Module","NgModule","declarations","imports","HelgolandCoreModule","exports","providers","D3SelectionRange"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n    AfterViewInit,\n    ChangeDetectorRef,\n    Component,\n    EventEmitter,\n    Input,\n    OnChanges,\n    Output,\n    SimpleChanges,\n    OnDestroy,\n} from '@angular/core';\nimport { DatasetOptions, HasLoadableContent, Mixin, Time, TimeInterval, Timespan } from '@helgoland/core';\n\nimport { D3PlotOptions } from '../model/d3-plot-options';\n\n@Component({\n    selector: 'n52-d3-overview-timeseries-graph',\n    template: `<n52-d3-timeseries-graph [datasetIds]=\"datasetIds\" [datasetOptions]=\"datasetOptions\" [reloadForDatasets]=\"reloadForDatasets\"\n    [timeInterval]=\"overviewTimespan\" [mainTimeInterval]=\"timespan\" [presenterOptions]=\"presenterOptions\" (onTimespanChanged)=\"timeSpanChanged($event)\"\n    (onContentLoading)=\"onGraphLoading($event)\"></n52-d3-timeseries-graph>`,\n    styles: [`:host .d3{height:100%}`]\n})\n@Mixin([HasLoadableContent])\nexport class D3OverviewTimeseriesGraphComponent implements OnChanges, AfterViewInit, HasLoadableContent, OnDestroy {\n\n    @Input()\n    public datasetIds: string[];\n\n    @Input()\n    public datasetOptions: Map<string, DatasetOptions>;\n\n    @Input()\n    public presenterOptions: D3PlotOptions;\n\n    @Input()\n    public timeInterval: TimeInterval;\n\n    @Input()\n    public rangefactor: number;\n\n    @Input()\n    public reloadForDatasets: string[];\n\n    @Output()\n    public onTimespanChanged: EventEmitter<Timespan> = new EventEmitter();\n\n    @Output()\n    public onLoading: EventEmitter<boolean> = new EventEmitter();\n\n    @Output()\n    public onContentLoading: EventEmitter<boolean> = new EventEmitter();\n\n    public isContentLoading: (loading: boolean) => void;\n\n    public overviewTimespan: Timespan;\n    public timespan: Timespan;\n\n    private init = false;\n\n    constructor(\n        protected timeSrvc: Time,\n        protected cd: ChangeDetectorRef\n    ) {\n        if (this.presenterOptions) {\n            this.presenterOptions.overview = true;\n        } else {\n            this.presenterOptions = { overview: true };\n        }\n    }\n\n    public ngAfterViewInit(): void {\n        this.rangefactor = this.rangefactor || 1;\n        this.calculateOverviewRange();\n        this.init = true;\n        this.cd.detectChanges();\n    }\n\n    public ngOnChanges(changes: SimpleChanges) {\n        if (changes.timeInterval && this.init) {\n            this.calculateOverviewRange();\n        }\n    }\n\n    public ngOnDestroy(): void {\n        this.cd.detach();\n    }\n\n    public timeSpanChanged(timespan: Timespan) {\n        this.onTimespanChanged.emit(timespan);\n    }\n\n    public onGraphLoading(loading: boolean) {\n        this.isContentLoading(loading);\n    }\n\n    private calculateOverviewRange() {\n        const timespan = this.timeSrvc.createTimespanOfInterval(this.timeInterval);\n        this.timespan = timespan;\n        this.overviewTimespan = this.timeSrvc.getBufferedTimespan(timespan, this.rangefactor);\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { TranslateService } from '@ngx-translate/core';\nimport { timeFormat, timeFormatLocale, TimeLocaleDefinition } from 'd3';\n\n/**\n * This service holds the translations for d3 charts time axis labels.\n * Add a new translation with the method 'addTimeFormatLocale' like this sample:\n *\n * addTimeFormatLocale('de',\n * {\n *   'dateTime': '%a %b %e %X %Y',\n *   'date': '%d-%m-%Y',\n *   'time': '%H:%M:%S',\n *   'periods': ['AM', 'PM'],\n *   'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],\n *   'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],\n *   'months': ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],\n *   'shortMonths': ['Jan', 'Feb', 'MÃ¤r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n * })\n *\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class D3TimeFormatLocaleService {\n\n  private timeFormatLocaleMapper: Map<string, TimeLocaleDefinition> = new Map();\n\n  constructor(\n    private translateService: TranslateService\n  ) { }\n\n  public addTimeFormatLocale(localeCode: string, definition: TimeLocaleDefinition) {\n    this.timeFormatLocaleMapper.set(localeCode, definition);\n  }\n\n  public getTimeLocale(specifier: string): (date: Date) => string {\n    const langCode = this.translateService.currentLang;\n    if (this.timeFormatLocaleMapper.has(langCode)) {\n      return timeFormatLocale(this.timeFormatLocaleMapper.get(langCode)).format(specifier);\n    } else {\n      return timeFormat(specifier);\n    }\n  }\n}\n","/**\n * Plot options for D3 component.\n *\n * @export\n */\nexport interface D3PlotOptions {\n\n    /**\n     * show reference values for a graph\n     *\n     * @memberof D3PlotOptions\n     */\n    showReferenceValues?: boolean;\n\n    /**\n     * requests the dataset data generalized\n     *\n     * @memberof D3PlotOptions\n     */\n    generalizeAllways?: boolean;\n\n    /**\n     * toggle panning (true) and zooming (false)\n     *\n     * @memberof D3PlotOptions\n     */\n    togglePanZoom?: boolean;\n\n    /**\n     * show or hide y axis\n     *\n     * @memberof D3PlotOptions\n     */\n    yaxis?: boolean;\n\n    /**\n     * show or hide grid lines inside plot\n     *\n     * @memberof D3PlotOptions\n     */\n    grid?: boolean;\n\n    /**\n     * show or hide lines with values when hovering with mouse\n     *\n     * @memberof D3PlotOptions\n     */\n    hoverable?: boolean;\n\n    /**\n     * style when hovering with mouse\n     *\n     * @memberof D3PlotOptions\n     */\n    hoverStyle?: HoveringStyle;\n\n    /**\n     * indicating if component should build overview diagram or not\n     *\n     * @memberof D3PlotOptions\n     */\n    overview?: boolean;\n\n    /**\n     * show copyright label\n     *\n     * default position is top left\n     *\n     * @memberof D3PlotOptions\n     */\n    copyright?: D3Copyright;\n\n    /**\n    * toggle dataset grouping by uom\n    * true = group y axis by uom\n    * false = single y axis for each timeseries\n    *\n    * @memberof D3PlotOptions\n    */\n    groupYaxis?: boolean;\n\n    /**\n    * show the label of the xaxis\n    *\n    * @memberof D3PlotOptions\n    */\n    showTimeLabel?: boolean;\n\n    /**\n    * Request the data with expanded=true, to get valueBeforeTimespan/valueAfterTimespan\n    *\n    * @memberof D3PlotOptions\n    */\n    requestBeforeAfterValues?: boolean;\n\n}\n\nexport interface D3Copyright {\n    label: string;\n    positionX?: 'right' | 'left';\n    positionY?: 'top' | 'bottom';\n}\n\nexport enum HoveringStyle {\n    none = 'none',\n    line = 'line',\n    point = 'point'\n}\n","import {\n    AfterViewInit,\n    Component,\n    ElementRef,\n    EventEmitter,\n    Input,\n    IterableDiffers,\n    Output,\n    ViewChild,\n    ViewEncapsulation,\n} from '@angular/core';\nimport {\n    ColorService,\n    Data,\n    DatasetApiInterface,\n    DatasetOptions,\n    DatasetPresenterComponent,\n    IDataset,\n    InternalDatasetId,\n    InternalIdHandler,\n    MinMaxRange,\n    Time,\n    Timeseries,\n    TimeseriesData,\n    Timespan,\n} from '@helgoland/core';\nimport { LangChangeEvent, TranslateService } from '@ngx-translate/core';\nimport * as d3 from 'd3';\nimport moment from 'moment';\n\nimport { D3TimeFormatLocaleService } from '../helper/d3-time-format-locale.service';\nimport { HighlightOutput } from '../model/d3-highlight';\nimport { D3PlotOptions, HoveringStyle } from '../model/d3-plot-options';\n\nexport interface DataEntry {\n    timestamp: number;\n    value: number;\n    xDiagCoord?: number;\n    yDiagCoord?: number;\n}\n\nexport interface InternalDataEntry {\n    internalId: string;\n    id?: number; // TODO needed?\n    color: string;\n    data: DataEntry[];\n    selected?: boolean;\n    points: {\n        fillColor: string\n    };\n    lines?: {\n        lineWidth?: number;\n        pointRadius?: number;\n    };\n    bars?: {\n        lineWidth?: number;\n    };\n    axisOptions: {\n        uom: string;\n        label?: string;\n        zeroBased?: boolean;\n        yAxisRange?: MinMaxRange;\n        autoRangeSelection?: boolean;\n        separateYAxis?: boolean;\n        parameters?: {\n            feature?: { id: String, label: String };\n            phenomenon?: { id: String, label: String };\n            offering?: { id: String, label: String };\n        };\n    };\n    visible: boolean;\n    focusLabelRect?: any;\n    focusLabel?: any;\n}\n\nexport interface DataConst extends IDataset {\n    data?: Data<[number, number]>;\n}\n\nexport interface YRanges {\n    uom: string;\n    range?: MinMaxRange; // necessary if grouped by uom\n    preRange?: MinMaxRange; // necessary if grouped by uom\n    originRange?: MinMaxRange; // necessary if grouped by uom\n    zeroBased: boolean;\n    autoRange: boolean;\n    outOfrange: boolean;\n    id?: string; // necessary if grouped by internalId\n    ids?: string[]; // necessary if grouped by uom\n    first?: boolean;\n    yScale?: d3.ScaleLinear<number, number>;\n    offset?: number;\n    parameters: {   // additional information for the y axis label\n        feature?: { id: String, label: String };\n        phenomenon?: { id: String, label: String };\n        offering?: { id: String, label: String };\n    };\n}\n\ninterface YScale {\n    buffer: number;\n    yScale: d3.ScaleLinear<number, number>;\n}\n\ninterface YAxisSelection {\n    id: string;\n    clicked: boolean;\n    ids?: Array<string>;\n    uom?: string;\n}\n\ninterface HighlightDataset {\n    id: string;\n    change: boolean;\n}\n\n@Component({\n    selector: 'n52-d3-timeseries-graph',\n    template: `<div class=\"d3\" #d3timeseries></div>\n`,\n    styles: [`.d3{height:100%;width:100%;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.d3 .grid .tick line{stroke:#d3d3d3;stroke-opacity:.7;shape-rendering:crispEdges}.d3 .graphDots{stroke-width:0;stroke-opacity:1}.d3 .graphDots .hover{stroke-width:20px;stroke-opacity:.5}.d3 .formerButton,.d3 .laterButton{fill:grey;opacity:.3}.d3 .formerButton:hover,.d3 .laterButton:hover{opacity:.6}.d3 .arrow{stroke:grey;stroke-width:3px}`],\n    encapsulation: ViewEncapsulation.None\n})\nexport class D3TimeseriesGraphComponent\n    extends DatasetPresenterComponent<DatasetOptions, D3PlotOptions>\n    implements AfterViewInit {\n\n    @Input()\n    // difference to timespan/timeInterval --> if brush, then this is the timespan of the main-diagram\n    public mainTimeInterval: Timespan;\n\n    @Output()\n    public onHighlightChanged: EventEmitter<HighlightOutput> = new EventEmitter();\n\n    @Output()\n    public onClickDataPoint: EventEmitter<TimeseriesData[]> = new EventEmitter();\n\n    @ViewChild('d3timeseries')\n    public d3Elem: ElementRef;\n\n    public highlightOutput: HighlightOutput;\n\n    // DOM elements\n    protected rawSvg: any; // d3.Selection<EnterElement, {}, null, undefined>;\n    protected graph: any;\n    protected graphFocus: any;\n    protected graphBody: any;\n    private dragRect: any;\n    private dragRectG: any;\n    private background: any;\n    private copyright: any;\n    private focusG: any;\n    private highlightFocus: any;\n    private highlightRect: any;\n    private highlightText: any;\n    private focuslabelTime: any;\n\n    // options for interaction\n    private dragging: boolean;\n    private dragStart: [number, number];\n    private dragCurrent: [number, number];\n    private draggingMove: boolean;\n    private dragMoveStart: number;\n    private dragMoveRange: [number, number];\n    private mousedownBrush: boolean;\n    private oldGroupYaxis: boolean;\n\n    // data types\n    protected preparedData: InternalDataEntry[] = []; // : DataSeries[]\n    protected datasetMap: Map<string, DataConst> = new Map();\n    protected listOfUoms: string[] = [];\n    protected yRangesEachUom: YRanges[] = []; // y array of objects containing ranges for each uom\n    protected dataYranges: YRanges[] = []; // y array of objects containing ranges of all datasets\n    private xAxisRange: Timespan; // x domain range\n    private xAxisRangeOrigin: any = []; // x domain range\n    private xAxisRangePan: [number, number]; // x domain range\n    private listOfSeparation = Array();\n    private yAxisSelect;\n\n    private xScaleBase: d3.ScaleTime<number, number>; // calculate diagram coord of x value\n    private yScaleBase: d3.ScaleLinear<number, number>; // calculate diagram coord of y value\n    // private dotsObjects: any[];\n    private labelTimestamp: number[];\n    private labelXCoord: number[];\n    private distLabelXCoord: number[];\n    private bufferSum: number;\n\n    private height: number;\n    private width: number;\n    private margin = {\n        top: 10,\n        right: 10,\n        bottom: 40,\n        left: 40\n    };\n    private maxLabelwidth = 0;\n    private opac = {\n        default: 0,\n        hover: 0.3,\n        click: 0.5\n    };\n    private addLineWidth = 2; // value added to linewidth\n    private loadingCounter = 0;\n    private currentTimeId: string;\n\n    // default plot options\n    private plotOptions: D3PlotOptions = {\n        showReferenceValues: false,\n        generalizeAllways: true,\n        togglePanZoom: true,\n        hoverable: true,\n        hoverStyle: HoveringStyle.point,\n        grid: true,\n        yaxis: true,\n        overview: false,\n        showTimeLabel: true,\n        requestBeforeAfterValues: false\n    };\n\n    constructor(\n        protected iterableDiffers: IterableDiffers,\n        protected api: DatasetApiInterface,\n        protected datasetIdResolver: InternalIdHandler,\n        protected timeSrvc: Time,\n        protected timeFormatLocaleService: D3TimeFormatLocaleService,\n        protected colorService: ColorService,\n        protected translateService: TranslateService\n    ) {\n        super(iterableDiffers, api, datasetIdResolver, timeSrvc, translateService);\n    }\n\n    public ngAfterViewInit(): void {\n        this.currentTimeId = this.uuidv4();\n        // this.dotsObjects = [];\n\n        this.rawSvg = d3.select(this.d3Elem.nativeElement)\n            .append('svg')\n            .attr('width', '100%')\n            .attr('height', '100%');\n\n        this.graph = this.rawSvg\n            .append('g')\n            .attr('transform', 'translate(' + (this.margin.left + this.maxLabelwidth) + ',' + this.margin.top + ')');\n\n        this.graphFocus = this.rawSvg\n            .append('g')\n            .attr('transform', 'translate(' + (this.margin.left + this.maxLabelwidth) + ',' + this.margin.top + ')');\n\n        this.mousedownBrush = false;\n        this.plotGraph();\n    }\n\n    protected onLanguageChanged(langChangeEvent: LangChangeEvent): void {\n        this.plotGraph();\n    }\n\n    public reloadDataForDatasets(datasetIds: string[]): void {\n        datasetIds.forEach(id => {\n            if (this.datasetMap.has(id)) {\n                this.loadDatasetData(this.datasetMap.get(id), true);\n            }\n        });\n    }\n\n    protected addDataset(id: string, url: string): void {\n        this.api.getSingleTimeseries(id, url).subscribe(\n            (timeseries) => this.loadAddedDataset(timeseries),\n            (error) => {\n                this.api.getDataset(id, url).subscribe(\n                    (dataset) => this.loadAddedDataset(dataset),\n                );\n            }\n        );\n    }\n    protected removeDataset(internalId: string): void {\n        this.dataYranges = [];\n        this.xAxisRangeOrigin = [];\n        this.datasetMap.delete(internalId);\n        let spliceIdx = this.preparedData.findIndex((entry) => entry.internalId === internalId);\n        if (spliceIdx >= 0) {\n            this.preparedData.splice(spliceIdx, 1);\n            if (this.preparedData.length <= 0) {\n                this.yRangesEachUom = [];\n                this.plotGraph();\n            } else {\n                this.preparedData.forEach((entry) => {\n                    this.processData(entry);\n                });\n            }\n        }\n    }\n    protected setSelectedId(internalId: string): void {\n        const tsData = this.preparedData.find((e) => e.internalId === internalId);\n        if (!tsData.selected || tsData.selected === undefined) {\n            tsData.selected = true;\n            tsData.lines.lineWidth += this.addLineWidth;\n            tsData.lines.pointRadius > 0 ? tsData.lines.pointRadius += this.addLineWidth : tsData.lines.pointRadius += 0;\n            tsData.bars.lineWidth += this.addLineWidth;\n\n            if (tsData.axisOptions.separateYAxis || !this.plotOptions.groupYaxis) {\n                this.checkYselector(tsData.internalId, tsData.axisOptions.uom);\n                if (this.yAxisSelect[internalId]) {\n                    this.yAxisSelect[internalId].clicked = true;\n                }\n            } else {\n                let identifier = tsData.axisOptions.uom;\n                let existingUom = this.yRangesEachUom.find(el => el.uom === identifier);\n\n                if (existingUom.ids.findIndex(el => el === internalId) >= 0) {\n                    this.checkYselector(identifier, tsData.axisOptions.uom);\n                    this.yAxisSelect[identifier].clicked = true;\n                    this.yAxisSelect[identifier].ids.push(internalId);\n\n                    // check axis for uom of dataset with selected internalId\n                    if (existingUom !== undefined && existingUom.ids !== undefined) {\n                        // only highlight axis of uom if all datasets with this uom are highlighted\n                        // count datasets for specific uom\n                        if (this.yAxisSelect[identifier].ids.length !== existingUom.ids.length) {\n                            this.yAxisSelect[identifier].clicked = false;\n                        } else {\n                            this.yAxisSelect[identifier].clicked = true;\n                        }\n                    }\n                }\n            }\n        }\n        this.plotGraph();\n    }\n    protected removeSelectedId(internalId: string): void {\n        const tsData = this.preparedData.find((e) => e.internalId === internalId);\n        if (tsData.selected || tsData.selected === undefined) {\n            tsData.selected = false;\n            tsData.lines.lineWidth -= this.addLineWidth;\n            tsData.lines.pointRadius > 0 ? tsData.lines.pointRadius -= this.addLineWidth : tsData.lines.pointRadius -= 0;\n            tsData.bars.lineWidth -= this.addLineWidth;\n\n            if (tsData.axisOptions.separateYAxis || !this.plotOptions.groupYaxis) {\n                this.checkYselector(tsData.internalId, tsData.axisOptions.uom);\n                if (this.yAxisSelect[tsData.internalId]) {\n                    this.yAxisSelect[tsData.internalId].clicked = false;\n                    if (this.yAxisSelect[tsData.internalId]) {\n                        this.yAxisSelect[tsData.internalId].ids = [];\n                    }\n                }\n            } else {\n                let identifier = tsData.axisOptions.uom;\n                this.checkYselector(identifier, tsData.axisOptions.uom);\n                this.yAxisSelect[identifier].ids = this.yAxisSelect[identifier].ids.filter(el => el !== internalId);\n                this.yAxisSelect[identifier].clicked = false;\n            }\n        }\n        this.plotGraph();\n    }\n    protected presenterOptionsChanged(options: D3PlotOptions): void {\n        this.oldGroupYaxis = this.plotOptions.groupYaxis;\n        if (this.plotOptions.hoverStyle !== HoveringStyle.point && options.hoverStyle === HoveringStyle.point) {\n            d3.select('g.d3line').attr('visibility', 'visible');\n        }\n        Object.assign(this.plotOptions, options);\n        if (this.rawSvg && this.yRangesEachUom) {\n            this.plotGraph();\n        }\n    }\n    protected datasetOptionsChanged(internalId: string, options: DatasetOptions, firstChange: boolean): void {\n        if (!firstChange && this.datasetMap.has(internalId)) {\n            this.loadDatasetData(this.datasetMap.get(internalId), false);\n        }\n    }\n    protected timeIntervalChanges(): void {\n        this.datasetMap.forEach((dataset) => {\n            this.loadDatasetData(dataset, false);\n        });\n    }\n    protected onResize(): void {\n        this.plotGraph();\n    }\n\n    public centerTime(timestamp: number): void {\n        const centeredTimespan = this.timeSrvc.centerTimespan(this.timespan, new Date(timestamp));\n        this.onTimespanChanged.emit(centeredTimespan);\n    }\n\n    private changeTime(from: number, to: number): void {\n        this.onTimespanChanged.emit(new Timespan(from, to));\n    }\n\n    private loadAddedDataset(dataset: IDataset): void {\n        this.datasetMap.set(dataset.internalId, dataset);\n        this.loadDatasetData(dataset, false);\n    }\n\n    // load data of dataset\n    private loadDatasetData(dataset: IDataset, force: boolean): void {\n        const datasetOptions = this.datasetOptions.get(dataset.internalId);\n        if (this.loadingCounter === 0) { this.onContentLoading.emit(true); }\n        this.loadingCounter++;\n\n        if (dataset instanceof Timeseries) {\n            const buffer = this.timeSrvc.getBufferedTimespan(this.timespan, 0.2);\n\n            this.api.getTsData<[number, number]>(dataset.id, dataset.url, buffer,\n                {\n                    format: 'flot',\n                    expanded: this.plotOptions.showReferenceValues || this.plotOptions.requestBeforeAfterValues,\n                    generalize: this.plotOptions.generalizeAllways || datasetOptions.generalize\n                },\n                { forceUpdate: force }\n            ).subscribe(\n                (result) => this.prepareTsData(dataset, result),\n                (error) => this.onError(error),\n                () => this.onCompleteLoadingData()\n            );\n        }\n    }\n\n    private onCompleteLoadingData(): void {\n        this.loadingCounter--;\n        if (this.loadingCounter === 0) { this.onContentLoading.emit(false); }\n    }\n\n    /**\n     * Function to prepare each dataset for the graph and adding it to an array of datasets.\n     * @param dataset {IDataset} Object of the whole dataset\n     */\n    private prepareTsData(dataset: IDataset, data: Data<[number, number]>): void {\n\n        // add surrounding entries to the set\n        if (data.valueBeforeTimespan) { data.values.unshift(data.valueBeforeTimespan); }\n        if (data.valueAfterTimespan) { data.values.push(data.valueAfterTimespan); }\n\n        this.datasetMap.get(dataset.internalId).data = data;\n        const datasetIdx = this.preparedData.findIndex((e) => e.internalId === dataset.internalId);\n        const styles = this.datasetOptions.get(dataset.internalId);\n\n        // TODO: change uom for testing\n        // if (this.preparedData.length > 0) {\n        //     dataset.uom = 'mc';\n        // }\n\n        // generate random color, if color is not defined\n        if (styles.color === undefined) {\n            styles.color = this.colorService.getColor();\n        }\n\n        // end of check for datasets\n        const dataEntry: InternalDataEntry = {\n            internalId: dataset.internalId,\n            id: (datasetIdx >= 0 ? datasetIdx : this.preparedData.length),\n            color: styles.color,\n            data: styles.visible ? data.values.map(d => ({ timestamp: d[0], value: d[1] })) : [],\n            points: {\n                fillColor: styles.color\n            },\n            lines: {\n                lineWidth: styles.lineWidth,\n                pointRadius: styles.pointRadius\n            },\n            bars: {\n                lineWidth: styles.lineWidth\n            },\n            axisOptions: {\n                uom: dataset.uom,\n                label: dataset.label,\n                zeroBased: styles.zeroBasedYAxis,\n                yAxisRange: styles.yAxisRange,\n                autoRangeSelection: styles.autoRangeSelection,\n                separateYAxis: styles.separateYAxis,\n                parameters: {\n                    feature: dataset.parameters.feature,\n                    phenomenon: dataset.parameters.phenomenon,\n                    offering: dataset.parameters.offering\n                }\n            },\n            visible: styles.visible\n        };\n\n        let separationIdx: number = this.listOfSeparation.findIndex((id) => id === dataset.internalId);\n        if (styles.separateYAxis) {\n            if (separationIdx < 0) {\n                this.listOfSeparation.push(dataset.internalId);\n            }\n        } else {\n            this.listOfSeparation = this.listOfSeparation.filter(entry => entry !== dataset.internalId);\n        }\n\n        // alternative linewWidth = this.plotOptions.selected.includes(dataset.uom)\n        if (this.selectedDatasetIds.indexOf(dataset.internalId) >= 0) {\n            dataEntry.lines.lineWidth += this.addLineWidth;\n            dataEntry.lines.pointRadius > 0 ? dataEntry.lines.pointRadius += this.addLineWidth : dataEntry.lines.pointRadius += 0;\n            dataEntry.bars.lineWidth += this.addLineWidth;\n\n            if (styles.separateYAxis) {\n                this.checkYselector(dataEntry.internalId, dataEntry.axisOptions.uom);\n                if (this.yAxisSelect[dataEntry.internalId]) {\n                    this.yAxisSelect[dataEntry.internalId].clicked = true;\n                    this.yAxisSelect[dataEntry.internalId].ids.push(dataEntry.internalId);\n                }\n            }\n        }\n\n        // check selected datasets for highlighting\n        if (this.yAxisSelect) {\n            if (styles.separateYAxis) {\n                if (this.yAxisSelect[dataEntry.axisOptions.uom]) {\n                    let idx = this.yAxisSelect[dataEntry.axisOptions.uom].ids.findIndex(el => el === dataEntry.internalId);\n                    if (idx >= 0) {\n                        this.yAxisSelect[dataEntry.axisOptions.uom].ids.splice(idx, 1);\n                    }\n                    let counted = this.countGroupedDatasets(dataEntry.axisOptions.uom, dataEntry.internalId);\n                    if (this.yAxisSelect[dataEntry.axisOptions.uom].ids.length === counted) {\n                        this.yAxisSelect[dataEntry.axisOptions.uom].clicked = true;\n                    }\n                }\n            } else {\n                if (this.yAxisSelect[dataEntry.internalId] && this.yAxisSelect[dataEntry.axisOptions.uom]) {\n                    if (this.yAxisSelect[dataEntry.internalId].clicked) {\n                        this.yAxisSelect[dataEntry.axisOptions.uom].ids.push(dataEntry.internalId);\n                    } else {\n                        this.yAxisSelect[dataEntry.axisOptions.uom].clicked = false;\n                    }\n                    delete this.yAxisSelect[dataEntry.internalId];\n                }\n            }\n        }\n\n        if (datasetIdx >= 0) {\n            this.preparedData[datasetIdx] = dataEntry;\n        } else {\n            this.preparedData.push(dataEntry);\n        }\n        this.addReferenceValueData(dataset.internalId, styles, data, dataset.uom);\n        this.processData(dataEntry);\n    }\n\n    /**\n     * Function to add referencevaluedata to the dataset (e.g. mean).\n     * @param internalId {String} String with the id of a dataset\n     * @param styles {DatasetOptions} Object containing information for dataset styling\n     * @param data {Data} Array of Arrays containing the measurement-data of the dataset\n     * @param uom {String} String with the uom of a dataset\n     */\n    private addReferenceValueData(internalId: string, styles: DatasetOptions, data: Data<[number, number]>, uom: string): void {\n        this.preparedData = this.preparedData.filter((entry) => {\n            return !entry.internalId.startsWith('ref' + internalId);\n        });\n        if (this.plotOptions.showReferenceValues) {\n            styles.showReferenceValues.forEach((refValue) => {\n                const refDataEntry: InternalDataEntry = {\n                    internalId: 'ref' + internalId + refValue.id,\n                    color: refValue.color,\n                    visible: true,\n                    data: data.referenceValues[refValue.id].map(d => ({ timestamp: d[0], value: d[1] })),\n                    points: {\n                        fillColor: refValue.color\n                    },\n                    lines: {\n                        lineWidth: 1\n                    },\n                    axisOptions: {\n                        uom: uom\n                    }\n                };\n                this.preparedData.push(refDataEntry);\n            });\n        }\n    }\n\n    /**\n     * Function that processes the data to calculate y axis range of each dataset.\n     * @param dataEntry {DataEntry} Object containing dataset related data.\n     */\n    protected processData(dataEntry: InternalDataEntry): void {\n        let calculatedRange: MinMaxRange;\n        let calculatedPreRange: MinMaxRange;\n        let calculatedOriginRange: MinMaxRange;\n        let predefinedRange: MinMaxRange;\n        if (dataEntry.axisOptions.yAxisRange && dataEntry.axisOptions.yAxisRange.min !== dataEntry.axisOptions.yAxisRange.max) {\n            predefinedRange = dataEntry.axisOptions.yAxisRange;\n        }\n        let autoDataExtent: boolean = dataEntry.axisOptions.autoRangeSelection;\n\n        // get min and max value of data\n        const dataExtent = d3.extent<DataEntry, number>(dataEntry.data, (d) => {\n            return d.value;\n        });\n\n        calculatedOriginRange = { min: dataExtent[0], max: dataExtent[1] };\n\n        let setDataExtent = false;\n\n        // calculate out of predefined range\n        if (predefinedRange && !this.plotOptions.overview) {\n            if (predefinedRange.min > predefinedRange.max) {\n                calculatedRange = { min: predefinedRange.max, max: predefinedRange.min };\n                calculatedPreRange = { min: predefinedRange.max, max: predefinedRange.min };\n            } else {\n                calculatedRange = { min: predefinedRange.min, max: predefinedRange.max };\n                calculatedPreRange = { min: predefinedRange.min, max: predefinedRange.max };\n            }\n            if (predefinedRange.min > dataExtent[1] || predefinedRange.max < dataExtent[0]) {\n                setDataExtent = autoDataExtent ? false : true;\n            }\n        } else {\n            setDataExtent = true;\n        }\n\n        if (setDataExtent) {\n            calculatedRange = { min: dataExtent[0], max: dataExtent[1] };\n            this.extendRange(calculatedRange);\n        }\n\n        // if style option 'zero based y-axis' is checked,\n        // the axis will be aligned to top 0 (with data below 0) or to bottom 0 (with data above 0)\n        // let zeroBasedValue = -1;\n        if (dataEntry.axisOptions.zeroBased && !this.plotOptions.overview) {\n            if (dataExtent[1] <= 0) {\n                calculatedRange.max = 0;\n                if (calculatedPreRange) { calculatedPreRange.max = 0; }\n            }\n            if (dataExtent[0] >= 0) {\n                calculatedRange.min = 0;\n                if (calculatedPreRange) { calculatedPreRange.min = 0; }\n            }\n        }\n\n        const newDatasetIdx = this.preparedData.findIndex((e) => e.internalId === dataEntry.internalId);\n\n        // set range, uom and id for each dataset\n        if (dataEntry.visible) {\n            this.dataYranges[newDatasetIdx] = {\n                uom: dataEntry.axisOptions.uom,\n                id: dataEntry.internalId,\n                zeroBased: dataEntry.axisOptions.zeroBased,\n                outOfrange: setDataExtent,\n                autoRange: autoDataExtent,\n                parameters: dataEntry.axisOptions.parameters\n            };\n            if (isFinite(calculatedRange.min) && isFinite(calculatedRange.max)) {\n                this.dataYranges[newDatasetIdx].range = calculatedRange;\n                this.dataYranges[newDatasetIdx].preRange = calculatedPreRange;\n                this.dataYranges[newDatasetIdx].originRange = calculatedOriginRange;\n            }\n        } else {\n            this.dataYranges[newDatasetIdx] = null;\n        }\n\n        // set range and array of IDs for each uom to generate y-axis later on\n        this.yRangesEachUom = [];\n        this.dataYranges.forEach((yRange) => {\n            if (yRange !== null) {\n                let idx: number = this.yRangesEachUom.findIndex((e) => e.uom === yRange.uom);\n                let yrangeObj: YRanges = {\n                    uom: yRange.uom,\n                    range: yRange.range,\n                    preRange: yRange.preRange,\n                    originRange: yRange.originRange,\n                    ids: [yRange.id],\n                    zeroBased: yRange.zeroBased,\n                    outOfrange: yRange.outOfrange,\n                    autoRange: yRange.autoRange,\n                    parameters: yRange.parameters\n                };\n\n                if (idx >= 0) {\n                    if (this.yRangesEachUom[idx].range) {\n                        if (yRange.range) {\n                            if (this.yRangesEachUom[idx].autoRange || yRange.autoRange) {\n                                if (yRange.preRange && this.yRangesEachUom[idx].preRange) {\n                                    this.checkCurrentLatest(idx, yRange, 'preRange');\n                                    this.yRangesEachUom[idx].range = this.yRangesEachUom[idx].preRange;\n                                } else {\n                                    this.checkCurrentLatest(idx, yRange, 'range');\n                                }\n                                this.yRangesEachUom[idx].autoRange = true;\n                            } else {\n                                if (yRange.outOfrange !== this.yRangesEachUom[idx].outOfrange) {\n                                    this.checkCurrentLatest(idx, yRange, 'originRange');\n                                    this.yRangesEachUom[idx].range = this.yRangesEachUom[idx].originRange;\n                                } else {\n                                    this.checkCurrentLatest(idx, yRange, 'range');\n                                }\n                            }\n                        }\n                    } else {\n                        this.takeLatest(idx, yRange, 'range');\n                    }\n\n                    this.yRangesEachUom[idx].ids.push(yRange.id);\n\n                } else {\n                    this.yRangesEachUom.push(yrangeObj);\n                }\n            }\n        });\n        if (this.graph) {\n            this.plotGraph();\n        }\n    }\n\n    /**\n     * Function to set range to default interval, if min and max of range are not set.\n     * @param range {MinMaxRange} range to be set\n     */\n    protected extendRange(range: MinMaxRange): void {\n        if (range.min === range.max) {\n            range.min = range.min - 1;\n            range.max = range.max + 1;\n        }\n    }\n\n    /**\n     * Function to check ranges for min and max range.\n     * @param idx {Number} Index of element\n     * @param obj {YRanges} new object to be compared with old\n     * @param pos {String} type of range (e.g. preRange, range, originRange)\n     */\n    private checkCurrentLatest(idx: number, obj: YRanges, pos: string): void {\n        if (this.yRangesEachUom[idx][pos].min > obj[pos].min && !isNaN(obj[pos].min)) {\n            this.yRangesEachUom[idx][pos].min = obj[pos].min;\n        }\n        if (this.yRangesEachUom[idx][pos].max < obj[pos].max && !isNaN(obj[pos].max)) {\n            this.yRangesEachUom[idx][pos].max = obj[pos].max;\n        }\n    }\n\n    /**\n     * Function to set min and max range.\n     * @param idx {Number} Index of element\n     * @param obj {YRanges} new object\n     * @param pos {String} type of range (e.g. preRange, range, originRange)\n     */\n    private takeLatest(idx: number, obj: YRanges, pos: string): void {\n        this.yRangesEachUom[idx][pos] = obj[pos];\n    }\n\n    /**\n     * Function that returns the height of the graph diagram.\n     */\n    private calculateHeight(): number {\n        return (this.d3Elem.nativeElement as HTMLElement).clientHeight - this.margin.top - this.margin.bottom + (this.plotOptions.showTimeLabel ? 0 : 20);\n    }\n\n    /**\n     * Function that returns the width of the graph diagram.\n     */\n    private calculateWidth(): number {\n        return this.rawSvg.node().width.baseVal.value - this.margin.left - this.margin.right - this.maxLabelwidth;\n    }\n\n    /**\n     * Function that returns the value range for building the y axis for each uom of every dataset.\n     * @param uom {String} String that is the uom of a dataset\n     */\n    private getyAxisRange(uom: string): MinMaxRange {\n        let rangeObj = this.yRangesEachUom.find(el => el.uom === uom);\n        if (rangeObj) {\n            // check for zero based y axis\n            // if (rangeObj.zeroBased) {\n            //     if (rangeObj.zeroBasedValue === 0) {\n            //         range.min = 0;\n            //     } else {\n            //         range.max = 0;\n            //     }\n            // }\n            return rangeObj.range;\n        }\n        return null; // error: uom does not exist\n    }\n\n    /**\n     * Function to plot the graph and its dependencies\n     * (graph line, graph axes, event handlers)\n     */\n    protected plotGraph(): void {\n        this.highlightOutput = {\n            timestamp: 0,\n            ids: new Map()\n        };\n        if (!this.yRangesEachUom) { return; }\n\n        this.preparedData.forEach((entry) => {\n            let idx: number = this.listOfUoms.findIndex((uom) => uom === entry.axisOptions.uom);\n            if (idx < 0) { this.listOfUoms.push(entry.axisOptions.uom); }\n        });\n\n        // adapt axis highlighting, when changing grouping of y axis\n        if (this.oldGroupYaxis !== this.plotOptions.groupYaxis) {\n            this.changeYselection();\n        }\n\n        this.height = this.calculateHeight();\n        this.width = this.calculateWidth();\n        this.graph.selectAll('*').remove();\n        this.graphFocus.selectAll('*').remove();\n\n        this.bufferSum = 0;\n        this.yScaleBase = null;\n\n        // get range of x and y axis\n        this.xAxisRange = this.timespan;\n\n        // #####################################################\n        let yAxisArray: YRanges[] = [];\n        if (this.plotOptions.groupYaxis || this.plotOptions.groupYaxis === undefined) {\n            yAxisArray = this.yRangesEachUom;\n            // push all listOfSeparation into yAxisArray\n            if (this.listOfSeparation.length > 0) {\n                this.listOfSeparation.forEach((sepId) => {\n                    let newEl: YRanges = this.dataYranges.find((el) => el !== null && el.id === sepId);\n                    if (newEl && (yAxisArray.findIndex(el => el.id === newEl.id) < 0)) {\n                        // if all dataset for specific uom are separated from grouping, the yaxis of this uom will be removed from axis\n                        let existingUom = yAxisArray.findIndex(el => el.uom === newEl.uom && (el.ids !== undefined || el.ids.length === 0));\n                        if (existingUom >= 0) {\n                            // delete id from ids\n                            let deleteId = yAxisArray[existingUom].ids.findIndex(id => id === sepId);\n                            if (deleteId >= 0) { yAxisArray[existingUom].ids.splice(deleteId, 1); }\n                            if (yAxisArray[existingUom].ids.length === 0) {\n                                // delete yAxisArray[existingUom]\n                                yAxisArray.splice(existingUom, 1);\n                            }\n                        }\n                        yAxisArray.push(newEl);\n                    }\n                });\n            }\n        } else {\n            yAxisArray = this.dataYranges;\n        }\n\n        yAxisArray.forEach((entry) => {\n            if (entry !== null) {\n                entry.first = (this.yScaleBase === null);\n                entry.offset = this.bufferSum;\n\n                let yAxisResult = this.drawYaxis(entry);\n                if (this.yScaleBase === null) {\n                    this.yScaleBase = yAxisResult.yScale;\n                    this.bufferSum = yAxisResult.buffer;\n                } else {\n                    this.bufferSum = yAxisResult.buffer;\n                }\n                entry.yScale = yAxisResult.yScale;\n            }\n        });\n\n        if (!this.yScaleBase) {\n            return;\n        }\n\n        // draw x and y axis\n        this.drawXaxis(this.bufferSum);\n\n        // create background as rectangle providing panning\n        this.background = this.graph.append('svg:rect')\n            .attr('width', this.width - this.bufferSum)\n            .attr('height', this.height)\n            .attr('id', 'backgroundRect')\n            .attr('fill', 'none')\n            .attr('stroke', 'none')\n            .attr('pointer-events', 'all')\n            .attr('transform', 'translate(' + this.bufferSum + ', 0)');\n\n        this.drawAllGraphLines();\n        this.addTimespanJumpButtons();\n\n        // #####################################################\n        // create background rect\n        if (!this.plotOptions.overview) {\n            // execute when it is not an overview diagram\n            // mouse events hovering\n            if (this.plotOptions.hoverable) {\n                if (this.plotOptions.hoverStyle === HoveringStyle.line) {\n                    this.createLineHovering();\n                } else {\n                    d3.select('g.d3line').attr('visibility', 'hidden');\n                }\n            }\n\n            if (this.plotOptions.togglePanZoom === false) {\n                this.background\n                    .call(d3.zoom()\n                        .on('start', this.zoomStartHandler)\n                        .on('zoom', this.zoomHandler)\n                        .on('end', this.zoomEndHandler)\n                    );\n            } else {\n                this.background\n                    .call(d3.drag()\n                        .on('start', this.panStartHandler)\n                        .on('drag', this.panMoveHandler)\n                        .on('end', this.panEndHandler));\n            }\n\n            this.createCopyrightLabel();\n        } else {\n            // execute when it is overview diagram\n            let interval: [number, number] = this.getXDomainByTimestamp();\n            let overviewTimespanInterval = [interval[0], interval[1]];\n\n            // create brush\n            let brush = d3.brushX()\n                .extent([[0, 0], [this.width, this.height]])\n                .on('end', () => {\n                    // on mouseclick change time after brush was moved\n                    if (this.mousedownBrush) {\n                        let timeByCoord: [number, number] = this.getTimestampByCoord(d3.event.selection[0], d3.event.selection[1]);\n                        this.changeTime(timeByCoord[0], timeByCoord[1]);\n                    }\n                    this.mousedownBrush = false;\n                });\n\n            // add brush to svg\n            this.background = this.graph.append('g')\n                .attr('width', this.width)\n                .attr('height', this.height)\n                .attr('pointer-events', 'all')\n                .attr('class', 'brush')\n                .call(brush)\n                .call(brush.move, overviewTimespanInterval);\n\n            /**\n             * add event to selection to prevent unnecessary re-rendering of brush\n             * add style of brush selection here\n             * e.g. 'fill' for color,\n             * 'stroke' for borderline-color,\n             * 'stroke-dasharray' for customizing borderline-style\n             */\n            this.background.selectAll('.selection')\n                .attr('stroke', 'none')\n                .on('mousedown', () => {\n                    this.mousedownBrush = true;\n                });\n\n            // do not allow clear selection\n            this.background.selectAll('.overlay')\n                .remove();\n\n            // add event to resizing handle to allow change time on resize\n            this.background.selectAll('.handle')\n                .style('fill', 'red')\n                .style('opacity', 0.3)\n                .attr('stroke', 'none')\n                .on('mousedown', () => {\n                    this.mousedownBrush = true;\n                });\n        }\n    }\n\n    private createPointHovering(entry: InternalDataEntry, line: d3.Line<DataEntry>) {\n        this.graphBody.selectAll('.hoverDots')\n            .data(entry.data.filter((d) => !isNaN(d.value)))\n            .enter().append('circle')\n            .attr('class', 'hoverDots')\n            .attr('id', (d: DataEntry) => 'hover-dot-' + d.timestamp + '-' + entry.id)\n            .attr('stroke', 'transparent')\n            .attr('fill', 'transparent')\n            .attr('cx', line.x())\n            .attr('cy', line.y())\n            .attr('r', entry.lines.pointRadius + 3)\n            .on('mouseover', (d: DataEntry) => this.mouseOverPointHovering(d, entry))\n            .on('mouseout', (d: DataEntry) => this.mouseOutPointHovering(d, entry))\n            .on('mousedown', (d: DataEntry) => this.clickDataPoint(d, entry));\n    }\n\n    private createLineHovering() {\n        this.background\n            .on('mousemove.focus', this.mousemoveHandler)\n            .on('mouseout.focus', this.mouseoutHandler);\n        // line inside graph\n        this.highlightFocus = this.focusG.append('svg:line')\n            .attr('class', 'mouse-focus-line')\n            .attr('x2', '0')\n            .attr('y2', '0')\n            .attr('x1', '0')\n            .attr('y1', '0')\n            .style('stroke', 'black')\n            .style('stroke-width', '1px');\n        this.preparedData.forEach((entry) => {\n            // label inside graph\n            entry.focusLabelRect = this.focusG.append('svg:rect')\n                .attr('class', 'mouse-focus-label')\n                .style('fill', 'white')\n                .style('stroke', 'none')\n                .style('pointer-events', 'none');\n            entry.focusLabel = this.focusG.append('svg:text')\n                .attr('class', 'mouse-focus-label')\n                .style('pointer-events', 'none')\n                .style('fill', entry.color)\n                .style('font-weight', 'lighter');\n            this.focuslabelTime = this.focusG.append('svg:text')\n                .style('pointer-events', 'none')\n                .attr('class', 'mouse-focus-time');\n        });\n    }\n\n    private clickDataPoint(d: DataEntry, entry: InternalDataEntry) {\n        console.log('click point');\n        if (d !== undefined) {\n            const externalId: InternalDatasetId = this.datasetIdResolver.resolveInternalId(entry.internalId);\n            const apiurl = externalId.url;\n            const timespan: Timespan = { from: d.timestamp, to: d.timestamp };\n\n            // request all timeseries that have data for the same offering and feature\n            this.api.getTimeseries(apiurl,\n                {\n                    offering: entry.axisOptions.parameters.offering.id,\n                    feature: entry.axisOptions.parameters.feature.id\n                }).subscribe(\n                    (tsArray) => {\n                        const timeseries = [];\n                        tsArray.forEach(ts => {\n                            timeseries.push(ts.id);\n                        });\n\n                        // request ts data by timeseries ID for specific offering and feature\n                        this.api.getTimeseriesData(apiurl, timeseries, timespan)\n                            .subscribe(\n                                (tsData) => this.onClickDataPoint.emit(tsData),\n                                (error) => console.error(error)\n                            );\n                    },\n                    (error) => console.error(error)\n                );\n        }\n    }\n\n    private addTimespanJumpButtons(): void {\n        let dataVisible = false;\n        let formerTimestamp = null;\n        let laterTimestamp = null;\n        if (this.plotOptions.requestBeforeAfterValues) {\n            this.preparedData.forEach((entry: InternalDataEntry) => {\n                const firstIdxInTimespan = entry.data.findIndex(e => (this.timespan.from < e[0] && this.timespan.to > e[0]) && isFinite(e[1]));\n                if (firstIdxInTimespan < 0) {\n                    const lastIdxInTimespan = entry.data.findIndex(e => (e[0] > this.timespan.from && e[0] > this.timespan.to) && isFinite(e[1]));\n                    if (lastIdxInTimespan >= 0) {\n                        laterTimestamp = entry.data[entry.data.length - 1][0];\n                    }\n                    const temp = entry.data.findIndex(e => (e[0] < this.timespan.from && e[0] < this.timespan.to) && isFinite(e[1]));\n                    if (temp >= 0) {\n                        formerTimestamp = entry.data[entry.data.length - 1][0];\n                    }\n                } else {\n                    dataVisible = true;\n                }\n            });\n        }\n        if (!dataVisible) {\n            const buttonWidth = 50;\n            const leftRight = 15;\n            if (formerTimestamp) {\n                const g = this.background.append('g');\n                g.append('svg:rect')\n                    .attr('class', 'formerButton')\n                    .attr('width', buttonWidth + 'px')\n                    .attr('height', this.height + 'px')\n                    .attr('transform', 'translate(' + this.bufferSum + ', 0)')\n                    .on('click', () => this.centerTime(formerTimestamp));\n                g.append('line')\n                    .attr('class', 'arrow')\n                    .attr('x1', 0 + this.bufferSum + leftRight + 'px')\n                    .attr('y1', this.height / 2 + 'px')\n                    .attr('x2', 0 + this.bufferSum + (buttonWidth - leftRight) + 'px')\n                    .attr('y2', this.height / 2 - (buttonWidth - leftRight) / 2 + 'px');\n                g.append('line')\n                    .attr('class', 'arrow')\n                    .attr('x1', 0 + this.bufferSum + leftRight + 'px')\n                    .attr('y1', this.height / 2 + 'px')\n                    .attr('x2', 0 + this.bufferSum + (buttonWidth - leftRight) + 'px')\n                    .attr('y2', this.height / 2 + (buttonWidth - leftRight) / 2 + 'px');\n            }\n            if (laterTimestamp) {\n                const g = this.background.append('g');\n                g.append('svg:rect')\n                    .attr('class', 'laterButton')\n                    .attr('width', '50px')\n                    .attr('height', this.height)\n                    .attr('transform', 'translate(' + (this.width - 50) + ', 0)')\n                    .on('click', () => this.centerTime(laterTimestamp));\n                g.append('line')\n                    .attr('class', 'arrow')\n                    .attr('x1', this.width - leftRight + 'px')\n                    .attr('y1', this.height / 2 + 'px')\n                    .attr('x2', this.width - (buttonWidth - leftRight) + 'px')\n                    .attr('y2', this.height / 2 - (buttonWidth - leftRight) / 2 + 'px');\n                g.append('line')\n                    .attr('class', 'arrow')\n                    .attr('x1', this.width - leftRight + 'px')\n                    .attr('y1', this.height / 2 + 'px')\n                    .attr('x2', this.width - (buttonWidth - leftRight) + 'px')\n                    .attr('y2', this.height / 2 + (buttonWidth - leftRight) / 2 + 'px');\n            }\n        }\n    }\n\n    private createCopyrightLabel(): void {\n        if (this.plotOptions.copyright) {\n            let background = this.getDimensions(this.background.node());\n            // default = top left\n            let x = 0; // left\n            let y = 0; // + this.margin.top; // top\n            this.copyright = this.graph.append('g');\n            let copyrightLabel = this.copyright.append('svg:text')\n                .text(this.plotOptions.copyright.label)\n                .attr('class', 'copyright')\n                .style('pointer-events', 'none')\n                .style('fill', 'grey');\n            if (this.plotOptions.copyright.positionX === 'right') {\n                x = background.w - this.margin.right - this.getDimensions(copyrightLabel.node()).w;\n            }\n            if (this.plotOptions.copyright.positionY === 'bottom') {\n                y = background.h - this.margin.top * 2;\n            }\n            let yTransform = y + this.getDimensions(copyrightLabel.node()).h - 3;\n            let xTransform = this.bufferSum + x;\n            copyrightLabel\n                .attr('transform', 'translate(' + xTransform + ', ' + yTransform + ')');\n            this.copyright.append('svg:rect')\n                .attr('class', 'copyright')\n                .style('fill', 'none')\n                .style('stroke', 'none')\n                .style('pointer-events', 'none')\n                .attr('width', this.getDimensions(copyrightLabel.node()).w)\n                .attr('height', this.getDimensions(copyrightLabel.node()).h)\n                .attr('transform', 'translate(' + xTransform + ', ' + y + ')');\n        }\n    }\n\n    /**\n     * Draws for every preprared data entry the graph line.\n     */\n    protected drawAllGraphLines(): void {\n        this.focusG = this.graphFocus.append('g');\n        if ((this.plotOptions.hoverStyle === HoveringStyle.point) && !this.plotOptions.overview) {\n            // create label for point hovering\n            this.highlightRect = this.focusG.append('svg:rect');\n            this.highlightText = this.focusG.append('svg:text');\n        }\n        this.preparedData.forEach((entry) => this.drawGraphLine(entry));\n    }\n\n    /**\n     * Function that calculates and returns the x diagram coordinate for the brush range\n     * for the overview diagram by the selected time interval of the main diagram.\n     * Calculate to get brush extent when main diagram time interval changes.\n     */\n    private getXDomainByTimestamp(): [number, number] {\n        /**\n         * calculate range of brush with timestamp and not diagram coordinates\n         * formula:\n         * brush_min =\n         * (overview_width / (overview_max - overview_min)) * (brush_min - overview_min)\n         * brus_max =\n         * (overview_width / (overview_max - overview_min)) * (brush_max - overview_min)\n         */\n\n        let minOverviewTimeInterval = this.timespan.from;\n        let maxOverviewTimeInterval = this.timespan.to;\n        let minDiagramTimestamp = this.mainTimeInterval.from;\n        let maxDiagramTimestamp = this.mainTimeInterval.to;\n        let diagramWidth = this.width;\n\n        let diffOverviewTimeInterval = maxOverviewTimeInterval - minOverviewTimeInterval;\n        let divOverviewTimeWidth = diagramWidth / diffOverviewTimeInterval;\n        let minCalcBrush: number = divOverviewTimeWidth * (minDiagramTimestamp - minOverviewTimeInterval);\n        let maxCalcBrush: number = divOverviewTimeWidth * (maxDiagramTimestamp - minOverviewTimeInterval);\n\n        return [minCalcBrush, maxCalcBrush];\n    }\n\n    /**\n     * Function that calculates and returns the timestamp for the main diagram calculated\n     * by the selected coordinate of the brush range.\n     * @param minCalcBrush {Number} Number with the minimum coordinate of the selected brush range.\n     * @param maxCalcBrush {Number} Number with the maximum coordinate of the selected brush range.\n     */\n    private getTimestampByCoord(minCalcBrush: number, maxCalcBrush: number): [number, number] {\n        /**\n         * calculate range of brush with timestamp and not diagram coordinates\n         * formula:\n         * minDiagramTimestamp =\n         * ((minCalcBrush / overview_width) * (overview_max - overview_min)) + overview_min\n         * maxDiagramTimestamp =\n         * ((maxCalcBrush / overview_width) * (overview_max - overview_min)) + overview_min\n         */\n\n        let minOverviewTimeInterval = this.timespan.from;\n        let maxOverviewTimeInterval = this.timespan.to;\n        let diagramWidth = this.width;\n\n        let diffOverviewTimeInterval = maxOverviewTimeInterval - minOverviewTimeInterval;\n        let minDiagramTimestamp: number = ((minCalcBrush / diagramWidth) * diffOverviewTimeInterval) + minOverviewTimeInterval;\n        let maxDiagramTimestamp: number = ((maxCalcBrush / diagramWidth) * diffOverviewTimeInterval) + minOverviewTimeInterval;\n\n        return [minDiagramTimestamp, maxDiagramTimestamp];\n    }\n\n    /**\n     * Function that draws the x axis to the svg element.\n     * @param bufferXrange {Number} Number with the distance between left edge and the beginning of the graph.\n     */\n    private drawXaxis(bufferXrange: number): void {\n        // range for x axis scale\n        this.xScaleBase = d3.scaleTime()\n            .domain([new Date(this.xAxisRange.from), new Date(this.xAxisRange.to)])\n            .range([bufferXrange, this.width]);\n\n        let xAxis = d3.axisBottom(this.xScaleBase)\n            .tickFormat(d => {\n                const date = new Date(d.valueOf());\n\n                const formatMillisecond = '.%L',\n                    formatSecond = ':%S',\n                    formatMinute = '%H:%M',\n                    formatHour = '%H:%M',\n                    formatDay = '%b %d',\n                    formatWeek = '%b %d',\n                    formatMonth = '%B',\n                    formatYear = '%Y';\n\n                const format = d3.timeSecond(date) < date ? formatMillisecond\n                    : d3.timeMinute(date) < date ? formatSecond\n                        : d3.timeHour(date) < date ? formatMinute\n                            : d3.timeDay(date) < date ? formatHour\n                                : d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? formatDay : formatWeek)\n                                    : d3.timeYear(date) < date ? formatMonth\n                                        : formatYear;\n                return this.timeFormatLocaleService.getTimeLocale(format)(new Date(d.valueOf()));\n            });\n\n        this.graph.append('g')\n            .attr('class', 'x axis')\n            .attr('transform', 'translate(0,' + this.height + ')')\n            .call(xAxis)\n            .selectAll('text')\n            .style('text-anchor', 'middle');\n\n        if (this.plotOptions.grid) {\n            // draw the x grid lines\n            this.graph.append('svg:g')\n                .attr('class', 'grid')\n                .attr('transform', 'translate(0,' + this.height + ')')\n                .call(xAxis\n                    .tickSize(-this.height)\n                    .tickFormat(() => '')\n                );\n        }\n\n        // draw upper axis as border\n        this.graph.append('svg:g')\n            .attr('class', 'x axis')\n            .call(d3.axisTop(this.xScaleBase).ticks(0).tickSize(0));\n\n        // text label for the x axis\n        if (this.plotOptions.showTimeLabel) {\n            this.graph.append('text')\n                .attr('x', (this.width + bufferXrange) / 2)\n                .attr('y', this.height + this.margin.bottom - 5)\n                .style('text-anchor', 'middle')\n                .text('time');\n        }\n    }\n\n    /**\n     * Function to draw the y axis for each dataset.\n     * Each uom has its own axis.\n     * @param entry {DataEntry} Object containing a dataset.\n     */\n    private drawYaxis(entry: YRanges): YScale {\n        let showAxis = (this.plotOptions.overview ? false : (this.plotOptions.yaxis === undefined ? true : this.plotOptions.yaxis));\n        // check for y axis grouping\n        let range;\n        if (this.plotOptions.groupYaxis || this.plotOptions.groupYaxis === undefined) {\n            // grouped axis\n            let uomIdx = this.listOfUoms.findIndex((uom) => uom === entry.uom);\n            if (uomIdx >= 0 && entry.ids && entry.ids.length > 1) {\n                // grouped with more than ony datasets (if uom has more than one datasets)\n                range = this.getyAxisRange(entry.uom);\n            } else {\n                // separated id (if not entry.uom) OR grouped, but only one dataset (if entry is grouped but has only one id => use range of this dataset)\n                let entryElem = this.dataYranges.find((el) => el !== null && (entry.id ? el.id === entry.id : el.id === entry.ids[0]));\n                if (entryElem) {\n                    range = entryElem.range;\n                    // range = entryElem.preRange ? entryElem.preRange : entryElem.range;\n                }\n            }\n        } else {\n            // ungrouped axis\n            let entryElem = this.dataYranges.find((el) => el !== null && el.id === entry.id);\n            if (entryElem) {\n                range = entryElem.preRange ? entryElem.preRange : entryElem.range;\n            }\n        }\n\n        let yMin = -1;\n        let yMax = 1;\n        if (range !== undefined && range !== null) {\n            yMin = range.min;\n            yMax = range.max;\n        }\n\n        // range for y axis scale\n        const rangeOffset = (yMax - yMin) * 0.10;\n        const yScale = d3.scaleLinear()\n            .domain([yMin - rangeOffset, yMax + rangeOffset])\n            .range([this.height, 0]);\n\n        let yAxisGen = d3.axisLeft(yScale).ticks(5);\n        let buffer = 0;\n\n        // only if yAxis should not be visible\n        if (!showAxis) {\n            yAxisGen\n                .tickFormat(() => '')\n                .tickSize(0);\n        }\n\n        // draw y axis\n        const axis = this.graph.append('svg:g')\n            .attr('class', 'y axis')\n            .call(yAxisGen);\n\n        // only if yAxis should be visible\n        if (showAxis) {\n            // draw y axis label\n            const text = this.graph.append('text')\n                .attr('transform', 'rotate(-90)')\n                .attr('dy', '1em')\n                .attr('class', 'yaxisTextLabel')\n                .style('font', '18px times')\n                .style('text-anchor', 'middle')\n                .style('fill', 'black')\n                .text((entry.id ? (entry.uom + ' @ ' + entry.parameters.feature.label) : entry.uom));\n            // .text((entry.id ? (entry.parameters.station + ' (' + entry.uom + ' ' + entry.parameters.phenomenon + ')') : entry.uom));\n\n            this.graph.selectAll('.yaxisTextLabel')\n                .call(this.wrapText, (axis.node().getBBox().height - 10), this.height / 2);\n\n            const axisWidth = axis.node().getBBox().width + 10 + this.getDimensions(text.node()).h;\n            // if yAxis should not be visible, buffer will be set to 0\n            buffer = (showAxis ? entry.offset + (axisWidth < this.margin.left ? this.margin.left : axisWidth) : 0);\n            const axisWidthDiv = (axisWidth < this.margin.left ? this.margin.left : axisWidth);\n\n            if (!entry.first) {\n                axis.attr('transform', 'translate(' + buffer + ', 0)');\n            } else {\n                buffer = axisWidthDiv - this.margin.left;\n                axis.attr('transform', 'translate(' + buffer + ', 0)');\n            }\n\n            let textOff = - (this.bufferSum);\n            if (entry.first) {\n                textOff = this.margin.left;\n            }\n            text.attr('y', 0 - textOff);\n\n            if (text) {\n                let textWidth = text.node().getBBox().width;\n                let textHeight = text.node().getBBox().height;\n                let textPosition = {\n                    x: text.node().getBBox().x,\n                    y: text.node().getBBox().y\n                };\n                let axisradius = 4;\n                let startOfPoints = {\n                    x: textPosition.y + textHeight / 2 + axisradius / 2, // + 2 because radius === 4\n                    y: Math.abs(textPosition.x + textWidth) - axisradius * 2\n                };\n                let pointOffset = 0;\n\n                if (entry.ids) {\n                    entry.ids.forEach((entryID) => {\n                        let dataentry = this.preparedData.find(el => el.internalId === entryID);\n                        if (dataentry) {\n                            this.graph.append('circle')\n                                .attr('class', 'axisDots')\n                                .attr('id', 'axisdot-' + entry.id)\n                                .attr('stroke', dataentry.color)\n                                .attr('fill', dataentry.color)\n                                .attr('cx', startOfPoints.x)\n                                .attr('cy', startOfPoints.y - pointOffset)\n                                .attr('r', axisradius);\n                            pointOffset += axisradius * 3;\n                        }\n                    });\n                } else {\n                    let dataentry = this.preparedData.find(el => el.internalId === entry.id);\n                    if (dataentry) {\n                        this.graph.append('circle')\n                            .attr('class', 'axisDots')\n                            .attr('id', 'axisdot-' + entry.id)\n                            .attr('stroke', dataentry.color)\n                            .attr('fill', dataentry.color)\n                            .attr('cx', startOfPoints.x)\n                            .attr('cy', startOfPoints.y - pointOffset)\n                            .attr('r', axisradius);\n                    }\n                }\n            }\n\n            // set id to uom, if group yaxis is toggled, else set id to dataset id\n            let id: string = (entry.id ? entry.id : entry.uom);\n            this.checkYselector(id, entry.uom);\n\n            const axisDiv = this.graph.append('rect')\n                // .attr('id', 'yaxis' + id)\n                .attr('class', 'axisDiv')\n                .attr('width', axisWidthDiv)\n                .attr('height', this.height)\n                .attr('fill', 'grey')\n                .attr('opacity', (this.yAxisSelect[id].clicked ? this.opac.click : this.opac.default))\n                .on('mouseover', (d, i, k) => {\n                    d3.select(k[0])\n                        .attr('opacity', this.opac.hover);\n                })\n                .on('mouseout', (d, i, k) => {\n                    if (!this.yAxisSelect[id].clicked) {\n                        d3.select(k[0])\n                            .attr('opacity', this.opac.default);\n                    } else {\n                        d3.select(k[0])\n                            .attr('opacity', this.opac.click);\n                    }\n                })\n                .on('mouseup', (d, i, k) => {\n                    if (!this.yAxisSelect[id].clicked) {\n                        d3.select(k[0])\n                            .attr('opacity', this.opac.default);\n                    } else {\n                        d3.select(k[0])\n                            .attr('opacity', this.opac.click);\n                    }\n                    this.yAxisSelect[id].clicked = !this.yAxisSelect[id].clicked;\n\n                    let entryArray = [];\n                    if (entry.id) {\n                        entryArray.push(entry.id);\n                    } else {\n                        entryArray = entry.ids;\n                    }\n                    this.highlightLine(entryArray);\n                });\n\n            if (!entry.first) {\n                axisDiv\n                    .attr('x', entry.offset)\n                    .attr('y', 0);\n            } else {\n                axisDiv\n                    .attr('x', 0 - this.margin.left - this.maxLabelwidth)\n                    .attr('y', 0);\n            }\n\n        }\n\n        // draw the y grid lines\n        if (this.yRangesEachUom.length === 1) {\n            this.graph.append('svg:g')\n                .attr('class', 'grid')\n                .attr('transform', 'translate(' + buffer + ', 0)')\n                .call(d3.axisLeft(yScale)\n                    .ticks(5)\n                    .tickSize(-this.width + buffer)\n                    .tickFormat(() => '')\n                );\n        }\n\n        return {\n            buffer,\n            yScale\n        };\n    }\n\n    /**\n     * Function to check whether object yAxisSelect exists with selected uom.\n     * If it does not exist, it will be created.\n     * @param identifier {String} String providing the selected uom or the selected dataset ID.\n     */\n    private checkYselector(identifier: string, uom: string): void {\n        if (this.yAxisSelect === undefined) {\n            this.yAxisSelect = {};\n        }\n\n        let selector: YAxisSelection = {\n            id: identifier,\n            ids: (this.yAxisSelect[identifier] !== undefined ? this.yAxisSelect[identifier].ids : []),\n            uom: uom,\n            clicked: (this.yAxisSelect[identifier] !== undefined ? this.yAxisSelect[identifier].clicked : false)\n        };\n\n        this.yAxisSelect[identifier] = selector;\n    }\n\n    /**\n     * Function to adapt y axis highlighting to selected TS or selected uom\n     */\n    private changeYselection(): void {\n        let groupList = {};\n        if (this.yAxisSelect) {\n            if (!this.plotOptions.groupYaxis) {\n                // before: group\n                for (let key in this.yAxisSelect) {\n                    if (this.yAxisSelect.hasOwnProperty(key)) {\n                        let el = this.yAxisSelect[key];\n                        if (el.ids.length > 0) {\n                            el.ids.forEach((id) => {\n                                let dataEl = this.preparedData.find((entry) => entry.internalId === id);\n                                let newSelector: YAxisSelection = {\n                                    id: id,\n                                    ids: [id],\n                                    clicked: true,\n                                    uom: dataEl.axisOptions.uom\n                                };\n                                groupList[id] = newSelector;\n                            });\n                        } else if (el.clicked && el.uom !== el.id) {\n                            let dataEl = this.preparedData.find((entry) => entry.internalId === el.id);\n                            let newSelector: YAxisSelection = {\n                                id: el.id,\n                                ids: [el.id],\n                                clicked: true,\n                                uom: dataEl.axisOptions.uom\n                            };\n                            groupList[el.id] = newSelector;\n                        }\n                    }\n                }\n            } else {\n                // before: no group\n                for (let key in this.yAxisSelect) {\n                    if (this.yAxisSelect.hasOwnProperty(key)) {\n                        let el = this.yAxisSelect[key];\n                        let dataEl = this.preparedData.find((entry) => entry.internalId === el.id);\n                        let selectionID;\n                        if (dataEl && dataEl.axisOptions.separateYAxis) {\n                            // selection is dataset with internalId\n                            selectionID = dataEl.internalId;\n                        } else {\n                            // selection is uom\n                            selectionID = el.uom;\n                        }\n                        if (!groupList[selectionID]) {\n                            let currentUom: YAxisSelection = {\n                                id: selectionID,\n                                ids: [],\n                                clicked: false,\n                                uom: el.uom\n                            };\n                            groupList[selectionID] = currentUom;\n                        }\n\n                        if (el.clicked) {\n                            groupList[selectionID].ids.push(el.id);\n                        }\n\n                        if (el.uom === selectionID) {\n                            // execute for grouped uom\n                            let groupedDatasets = this.countGroupedDatasets(selectionID, el.uom);\n                            if (groupList[selectionID].ids.length === groupedDatasets) {\n                                groupList[selectionID].clicked = true;\n                            }\n                        } else if (el.clicked) {\n                            // execute for ungrouped dataset\n                            groupList[selectionID].clicked = true;\n                        }\n                    }\n                }\n            }\n            this.yAxisSelect = {}; // unselect all - y axis\n            this.yAxisSelect = groupList;\n        }\n        this.oldGroupYaxis = this.plotOptions.groupYaxis;\n    }\n\n    /**\n     * Function that returns the amount of datasets that are grouped with the same uom\n     * @param uom {String} uom\n     * @param id {String} internalId of the dataset that can be skipped\n     * returns {Number} amount of datasets with the given uom\n     */\n    private countGroupedDatasets(uom: string, id: string): number {\n        let arrayUomCount = 0;\n        this.dataYranges.forEach(el => {\n            if (el !== null && el.uom === uom && el.id !== id) {\n                let idx = this.preparedData.findIndex(ds => ds.internalId === el.id && ds.axisOptions.separateYAxis === false);\n                if (idx >= 0) { arrayUomCount++; }\n            }\n        });\n        return arrayUomCount;\n    }\n\n    /**\n     * Function to set selected Ids that should be highlighted.\n     * @param ids {Array} Array of Strings containing the Ids.\n     * @param uom {String} String with the uom for the selected Ids\n     */\n    private highlightLine(ids: string[]): void {\n        let changeFalse: HighlightDataset[] = [];\n        let changeTrue: HighlightDataset[] = [];\n        ids.forEach((ID) => {\n            if (this.selectedDatasetIds.indexOf(ID) >= 0) {\n                changeFalse.push({ id: ID, change: false });\n            }\n            changeTrue.push({ id: ID, change: true });\n        });\n\n        if (ids.length === changeFalse.length) {\n            this.changeSelectedIds(changeFalse, true);\n        } else {\n            this.changeSelectedIds(changeTrue, false);\n        }\n    }\n\n    /**\n     * Function that changes state of selected Ids.\n     */\n    private changeSelectedIds(toHighlightDataset: HighlightDataset[], change: boolean): void {\n        if (change) {\n            toHighlightDataset.forEach((obj) => {\n                this.removeSelectedId(obj.id);\n                this.selectedDatasetIds.splice(this.selectedDatasetIds.findIndex((entry) => entry === obj.id), 1);\n            });\n        } else {\n            toHighlightDataset.forEach((obj) => {\n                if (this.selectedDatasetIds.indexOf(obj.id) < 0) {\n                    this.setSelectedId(obj.id);\n                    this.selectedDatasetIds.push(obj.id);\n                }\n            });\n        }\n\n        this.onDatasetSelected.emit(this.selectedDatasetIds);\n        this.plotGraph();\n    }\n\n    /**\n     * Function to draw the graph line for each dataset.\n     * @param entry {DataEntry} Object containing a dataset.\n     */\n    protected drawGraphLine(entry: InternalDataEntry): void {\n        // const getYaxisRange = this.yRangesEachUom.find((obj) => obj.ids.indexOf(entry.internalId) > -1);\n        // check for y axis grouping\n        let getYaxisRange = this.getYaxisRange(entry);\n\n        if (entry.data.length > 0) {\n            if (getYaxisRange !== undefined) {\n                let yScaleBase = getYaxisRange.yScale;\n\n                // #####################################################\n                // create body to clip graph\n                // unique ID generated through the current time (current time when initialized)\n                let querySelectorClip = 'clip' + this.currentTimeId;\n\n                this.graph\n                    .append('svg:clipPath')\n                    .attr('id', querySelectorClip)\n                    .append('svg:rect')\n                    .attr('x', this.bufferSum)\n                    .attr('y', 0)\n                    .attr('width', this.width - this.bufferSum)\n                    .attr('height', this.height);\n\n                // draw grah line\n                this.graphBody = this.graph\n                    .append('g')\n                    .attr('clip-path', 'url(#' + querySelectorClip + ')');\n\n                // create graph line\n                let line = this.createLine(this.xScaleBase, yScaleBase);\n\n                this.graphBody\n                    .append('svg:path')\n                    .datum(entry.data)\n                    .attr('class', 'line')\n                    .attr('fill', 'none')\n                    .attr('stroke', entry.color)\n                    .attr('stroke-width', entry.lines.lineWidth)\n                    .attr('d', line);\n\n                this.graphBody.selectAll('.graphDots')\n                    .data(entry.data.filter((d) => !isNaN(d.value)))\n                    .enter().append('circle')\n                    .attr('class', 'graphDots')\n                    .attr('id', (d: DataEntry) => 'dot-' + d.timestamp + '-' + entry.id)\n                    .attr('stroke', entry.color)\n                    .attr('fill', entry.color)\n                    .attr('cx', line.x())\n                    .attr('cy', line.y())\n                    .attr('r', entry.lines.pointRadius);\n\n                if (this.plotOptions.hoverStyle === HoveringStyle.point) {\n                    this.createPointHovering(entry, line);\n                }\n            }\n        }\n    }\n\n    /**\n     * Function that shows labeling via mousmove.\n     */\n    private mousemoveHandler = (): void => {\n        const coords = d3.mouse(this.background.node());\n        this.labelTimestamp = [];\n        this.labelXCoord = [];\n        this.distLabelXCoord = [];\n        this.preparedData.forEach((entry, entryIdx) => {\n            const idx = this.getItemForX(coords[0] + this.bufferSum, entry.data);\n            this.showDiagramIndicator(entry, idx, coords[0], entryIdx);\n        });\n\n        let outputIds: string[] = [];\n        for (const key in this.highlightOutput.ids) {\n            if (this.highlightOutput.ids.hasOwnProperty(key)) {\n                outputIds.push(key);\n            }\n        }\n\n        if (outputIds.length <= 0) {\n            // do not show line in graph when no data available for timestamp\n            this.focusG.style('visibility', 'hidden');\n        } else {\n            let last = 0,\n                visible = false,\n                first = true,\n                labelArray: [d3.BaseType, d3.BaseType][] = [],\n                textRectArray: d3.BaseType[] = d3.selectAll('.focus-visibility').nodes();\n\n            // get and sort all text labels and rectangle of the text labels and combine related\n            for (let i = 0; i < textRectArray.length; i += 2) {\n                labelArray.push([textRectArray[i], textRectArray[i + 1]]);\n            }\n            // sory by y coordinate\n            labelArray.sort((a, b) => parseFloat(d3.select(a[0]).attr('y')) - parseFloat(d3.select(b[0]).attr('y')));\n\n            // translate if overlapping\n            labelArray.forEach((el) => {\n                // pairs of 2 objects (rectangle (equal) and label (odd))\n                d3.select(el[0])\n                    .attr('transform', (d, i, f) => {\n                        if (d3.select(el[0]).attr('visibility') !== 'hidden') {\n                            visible = true;\n                            let ycoord: number = parseFloat(d3.select(el[0]).attr('y'));\n                            let offset = 0;\n                            if (!first) {\n                                offset = Math.max(0, (last + 30) - ycoord);\n                                if (offset < 10) { offset = 10; }\n                            }\n                            if (offset > 0) {\n                                return 'translate(0, ' + offset + ')';\n                            }\n                        }\n                        return 'translate(0, 0)';\n                    });\n\n                d3.select(el[1])\n                    .attr('transform', (d, i, f) => {\n                        if (d3.select(el[1]).attr('visibility') !== 'hidden') {\n                            visible = true;\n                            let ycoord: number = parseFloat(d3.select(el[0]).attr('y'));\n                            let offset = 0;\n                            if (!first) {\n                                offset = Math.max(0, (last + 30) - ycoord);\n                                if (offset < 10) { offset = 10; }\n                            }\n                            last = offset + ycoord;\n                            if (offset > 0) {\n                                return 'translate(0, ' + offset + ')';\n                            }\n                        }\n                        return 'translate(0, 0)';\n                    });\n\n                if (visible) {\n                    first = false;\n                }\n\n            });\n        }\n        this.onHighlightChanged.emit(this.highlightOutput);\n    }\n\n    /**\n     * Function that hides the labeling inside the graph.\n     */\n    private mouseoutHandler = (): void => {\n        this.hideDiagramIndicator();\n    }\n\n    /**\n     * Function starting the drag handling for the diagram.\n     */\n    private panStartHandler = (): void => {\n        this.draggingMove = false;\n        this.dragMoveStart = d3.event.x;\n        this.dragMoveRange = [this.xAxisRange.from, this.xAxisRange.to];\n    }\n\n    /**\n     * Function that controlls the panning (dragging) of the graph.\n     */\n    private panMoveHandler = (): void => {\n        this.draggingMove = true;\n        if (this.dragMoveStart && this.draggingMove) {\n            let diff = -(d3.event.x - this.dragMoveStart); // d3.event.subject.x);\n            let amountTimestamp = this.dragMoveRange[1] - this.dragMoveRange[0];\n            let ratioTimestampDiagCoord = amountTimestamp / this.width;\n            let newTimeMin = this.dragMoveRange[0] + (ratioTimestampDiagCoord * diff);\n            let newTimeMax = this.dragMoveRange[1] + (ratioTimestampDiagCoord * diff);\n\n            this.xAxisRangePan = [newTimeMin, newTimeMax];\n            this.timespan = { from: this.xAxisRangePan[0], to: this.xAxisRangePan[1] };\n            this.plotGraph();\n        }\n    }\n\n    /**\n     * Function that ends the dragging control.\n     */\n    private panEndHandler = (): void => {\n        if (this.xAxisRangePan) {\n            this.changeTime(this.xAxisRangePan[0], this.xAxisRangePan[1]);\n            this.plotGraph();\n            this.dragMoveStart = null;\n            this.draggingMove = false;\n            this.xAxisRangePan = null;\n        }\n    }\n\n    /**\n     * Function that starts the zoom handling.\n     */\n    private zoomStartHandler = (): void => {\n        this.dragging = false;\n        // dependent on point or line hovering\n        this.dragStart = d3.mouse(this.background.node());\n        this.xAxisRangeOrigin.push([this.xAxisRange.from, this.xAxisRange.to]);\n    }\n\n    /**\n     * Function that draws a rectangle when zoom is started and the mouse is moving.\n     */\n    private zoomHandler = (): void => {\n        this.dragging = true;\n        this.drawDragRectangle();\n    }\n\n    /**\n     * Function that ends the zoom handling and calculates the via zoom selected time interval.\n     */\n    private zoomEndHandler = (): void => {\n        if (!this.dragStart || !this.dragging) {\n            if (this.xAxisRangeOrigin[0]) {\n                // back to origin range (from - to)\n                this.changeTime(this.xAxisRangeOrigin[0][0], this.xAxisRangeOrigin[0][1]);\n                this.xAxisRangeOrigin = [];\n                this.plotGraph();\n            }\n        } else {\n            let xDomainRange;\n            if (this.dragStart[0] <= this.dragCurrent[0]) {\n                xDomainRange = this.getxDomain(this.dragStart[0], this.dragCurrent[0]);\n            } else {\n                xDomainRange = this.getxDomain(this.dragCurrent[0], this.dragStart[0]);\n            }\n            this.xAxisRange = { from: xDomainRange[0], to: xDomainRange[1] };\n            this.changeTime(this.xAxisRange.from, this.xAxisRange.to);\n            this.plotGraph();\n        }\n        this.dragStart = null;\n        this.dragging = false;\n        this.resetDrag();\n    }\n\n    private createLine(xScaleBase: d3.ScaleTime<number, number>, yScaleBase: d3.ScaleLinear<number, number>) {\n        return d3.line<DataEntry>()\n            .defined((d) => !isNaN(d.value))\n            .x((d) => {\n                const xDiagCoord = xScaleBase(d.timestamp);\n                if (!isNaN(xDiagCoord)) {\n                    d.xDiagCoord = xDiagCoord;\n                    return xDiagCoord;\n                }\n            })\n            .y((d) => {\n                const yDiagCoord = yScaleBase(d.value);\n                if (!isNaN(yDiagCoord)) {\n                    d.yDiagCoord = yDiagCoord;\n                    return yDiagCoord;\n                }\n            })\n            .curve(d3.curveLinear);\n    }\n\n    private mouseOverPointHovering(d: DataEntry, entry: InternalDataEntry) {\n        if (d !== undefined) {\n            let coords = d3.mouse(this.background.node());\n            let dataset = this.datasetMap.get(entry.internalId);\n            let rectBack = this.background.node().getBBox();\n            if (coords[0] >= 0 && coords[0] <= rectBack.width && coords[1] >= 0 && coords[1] <= rectBack.height) {\n                // highlight hovered dot\n                d3.select('#dot-' + d.timestamp + '-' + entry.id).attr('opacity', 0.8).attr('r', '8px');\n\n                this.highlightRect.style('visibility', 'visible');\n                this.highlightText.style('visibility', 'visible');\n\n                // create text for hovering label\n                let dotLabel = this.highlightText\n                    .text(`${d.value} ${entry.axisOptions.uom} ${moment(d.timestamp).format('DD.MM.YY HH:mm')}`)\n                    .attr('class', 'mouseHoverDotLabel')\n                    .style('pointer-events', 'none')\n                    .style('fill', 'black');\n                let onLeftSide = false;\n                if ((this.background.node().getBBox().width + this.bufferSum) / 2 > coords[0]) {\n                    onLeftSide = true;\n                }\n                let rectX: number = d.xDiagCoord + 15;\n                let rectY: number = d.yDiagCoord;\n                let rectW: number = this.getDimensions(dotLabel.node()).w + 8;\n                let rectH: number = this.getDimensions(dotLabel.node()).h; // + 4;\n                if (!onLeftSide) {\n                    rectX = d.xDiagCoord - 15 - rectW;\n                    rectY = d.yDiagCoord;\n                }\n                if ((coords[1] + rectH + 4) > this.background.node().getBBox().height) {\n                    // when label below x axis\n                    console.log('Translate label to a higher place. - not yet implemented');\n                }\n                // create hovering label\n                let dotRectangle = this.highlightRect\n                    .attr('class', 'mouseHoverDotRect')\n                    .style('fill', 'white')\n                    .style('fill-opacity', 1)\n                    .style('stroke', entry.color)\n                    .style('stroke-width', '1px')\n                    .style('pointer-events', 'none')\n                    .attr('width', rectW)\n                    .attr('height', rectH)\n                    .attr('transform', 'translate(' + rectX + ', ' + rectY + ')');\n                let labelX: number = d.xDiagCoord + 4 + 15;\n                let labelY: number = d.yDiagCoord + this.getDimensions(dotRectangle.node()).h - 4;\n                if (!onLeftSide) {\n                    labelX = d.xDiagCoord - rectW + 4 - 15;\n                    labelY = d.yDiagCoord + this.getDimensions(dotRectangle.node()).h - 4;\n                }\n                this.highlightText\n                    .attr('transform', 'translate(' + labelX + ', ' + labelY + ')');\n                // generate output of highlighted data\n                this.highlightOutput = {\n                    timestamp: d.timestamp,\n                    ids: new Map().set(entry.internalId, { timestamp: d.timestamp, value: d.value })\n                };\n                this.onHighlightChanged.emit(this.highlightOutput);\n            }\n        }\n    }\n\n    private mouseOutPointHovering(d: DataEntry, entry: InternalDataEntry) {\n        if (d !== undefined) {\n            // unhighlight hovered dot\n            d3.select('#dot-' + d.timestamp + '-' + entry.id)\n                .attr('opacity', 1)\n                .attr('r', entry.lines.pointRadius);\n            // make label invisible\n            this.highlightRect\n                .style('visibility', 'hidden');\n            this.highlightText\n                .style('visibility', 'hidden');\n        }\n    }\n\n    protected getYaxisRange(entry: InternalDataEntry): YRanges {\n        // check if entry dataset should be separated or entry datasets should be grouped\n        if (!entry.axisOptions.separateYAxis && (this.plotOptions.groupYaxis || this.plotOptions.groupYaxis === undefined)) {\n            return this.yRangesEachUom.find((obj) => {\n                if (obj !== null && obj.uom === entry.axisOptions.uom) {\n                    return true;\n                } // uom does exist in this.yRangesEachUom\n            });\n        } else {\n            return this.dataYranges.find((obj) => {\n                if (obj !== null && obj.id === entry.internalId) {\n                    return true;\n                } // id does exist in this.dataYranges\n            });\n        }\n    }\n\n    /**\n     * Function that returns the timestamp of provided x diagram coordinates.\n     * @param start {Number} Number with the minimum diagram coordinate.\n     * @param end {Number} Number with the maximum diagram coordinate.\n     */\n    private getxDomain(start: number, end: number): [number, number] {\n        let domMinArr = [];\n        let domMaxArr = [];\n        let domMin: number;\n        let domMax: number;\n        let tmp;\n        let lowestMin = Number.POSITIVE_INFINITY;\n        let lowestMax = Number.POSITIVE_INFINITY;\n\n        start += this.bufferSum;\n        end += this.bufferSum;\n\n        this.preparedData.forEach((entry) => {\n            domMinArr.push(entry.data.find((elem, index, array) => {\n                if (elem.xDiagCoord) {\n                    if (elem.xDiagCoord >= start) {\n                        return array[index] !== undefined;\n                    }\n                }\n            }));\n            domMaxArr.push(entry.data.find((elem, index, array) => {\n                if (elem.xDiagCoord >= end) {\n                    return array[index] !== undefined;\n                }\n            }));\n        });\n\n        for (let i = 0; i <= domMinArr.length - 1; i++) {\n            if (domMinArr[i] != null) {\n                tmp = domMinArr[i].xDiagCoord;\n                if (tmp < lowestMin) {\n                    lowestMin = tmp;\n                    domMin = domMinArr[i].timestamp;\n                }\n            }\n        }\n        for (let j = 0; j <= domMaxArr.length - 1; j++) {\n            if (domMaxArr[j] != null) {\n                tmp = domMaxArr[j].xDiagCoord;\n                if (tmp < lowestMax) {\n                    lowestMax = tmp;\n                    domMax = domMaxArr[j].timestamp;\n                }\n            }\n        }\n        return [domMin, domMax];\n    }\n\n    /**\n     * Function that configurates and draws the rectangle.\n     */\n    private drawDragRectangle(): void {\n        if (!this.dragStart) { return; }\n        this.dragCurrent = d3.mouse(this.background.node());\n\n        const x1 = Math.min(this.dragStart[0], this.dragCurrent[0]);\n        const x2 = Math.max(this.dragStart[0], this.dragCurrent[0]);\n\n        if (!this.dragRect && !this.dragRectG) {\n\n            this.dragRectG = this.graph.append('g')\n                .style('fill-opacity', .2)\n                .style('fill', 'blue');\n\n            this.dragRect = this.dragRectG.append('rect')\n                .attr('width', x2 - x1)\n                .attr('height', this.height)\n                .attr('x', x1 + this.bufferSum)\n                .attr('class', 'mouse-drag')\n                .style('pointer-events', 'none');\n        } else {\n            this.dragRect.attr('width', x2 - x1)\n                .attr('x', x1 + this.bufferSum);\n        }\n    }\n\n    /**\n     * Function that disables the drawing rectangle control.\n     */\n    private resetDrag(): void {\n        if (this.dragRectG) {\n            this.dragRectG.remove();\n            this.dragRectG = null;\n            this.dragRect = null;\n        }\n    }\n\n    /**\n     * Function that returns the metadata of a specific entry in the dataset.\n     * @param x {Number} Coordinates of the mouse inside the diagram.\n     * @param data {DataEntry} Array with the data of each dataset entry.\n     */\n    private getItemForX(x: number, data: DataEntry[]): number {\n        const index = this.xScaleBase.invert(x);\n        const bisectDate = d3.bisector((d: DataEntry) => {\n            return d[0];\n        }).left;\n        return bisectDate(data, index);\n    }\n\n    /**\n     * Function that disables the labeling.\n     */\n    private hideDiagramIndicator(): void {\n        this.focusG.style('visibility', 'hidden');\n        d3.selectAll('.focus-visibility')\n            .attr('visibility', 'hidden');\n    }\n\n    /**\n     * Function that enables the lableing of each dataset entry.\n     * @param entry {InternalDataEntry} Object containing the dataset.\n     * @param idx {Number} Number with the position of the dataset entry in the data array.\n     * @param xCoordMouse {Number} Number of the x coordinate of the mouse.\n     * @param entryIdx {Number} Number of the index of the entry.\n     */\n    private showDiagramIndicator = (entry: InternalDataEntry, idx: number, xCoordMouse: number, entryIdx: number): void => {\n        const item: DataEntry = entry.data[idx];\n        this.labelXCoord[entryIdx] = null;\n        this.distLabelXCoord[entryIdx] = null;\n\n        if (item !== undefined && item.yDiagCoord && item[1] !== undefined) {\n            // create line where mouse is\n            this.focusG.style('visibility', 'visible');\n            // show label if data available for time\n            this.chVisLabel(entry, true, entryIdx);\n\n            let xMouseAndBuffer = xCoordMouse + this.bufferSum;\n            let labelBuffer = ((this.timespan.from / (this.timespan.to - this.timespan.from)) * 0.0001)\n                * ((this.timespan.from / (this.timespan.to - this.timespan.from)) * 0.0001);\n\n            labelBuffer = Math.max(10, labelBuffer);\n\n            this.showLabelValues(entry, item);\n            this.showTimeIndicatorLabel(item, entryIdx, xMouseAndBuffer);\n\n            if (item.xDiagCoord >= this.background.node().getBBox().width + this.bufferSum || xMouseAndBuffer < item.xDiagCoord - labelBuffer) {\n                this.chVisLabel(entry, false, entryIdx);\n            }\n\n            if (xMouseAndBuffer < item.xDiagCoord) {\n                if (entry.data[idx - 1] && (Math.abs(entry.data[idx - 1].xDiagCoord - xMouseAndBuffer) < Math.abs(item.xDiagCoord - xMouseAndBuffer))) {\n                    this.chVisLabel(entry, false, entryIdx);\n                    // show closest element to mouse\n                    this.showLabelValues(entry, entry.data[idx - 1]);\n                    this.showTimeIndicatorLabel(entry.data[idx - 1], entryIdx, xMouseAndBuffer);\n                    this.chVisLabel(entry, true, entryIdx);\n\n                    // check for graph width and range between data point and mouse\n                    if (entry.data[idx - 1].xDiagCoord >= this.background.node().getBBox().width + this.bufferSum\n                        || entry.data[idx - 1].xDiagCoord <= this.bufferSum\n                        || entry.data[idx - 1].xDiagCoord + labelBuffer < xMouseAndBuffer) {\n                        this.chVisLabel(entry, false, entryIdx);\n                    }\n                }\n            }\n        } else {\n            // TODO: set hovering for labelbuffer after last and before first value of the graph\n            // hide label if no data available for time\n            this.chVisLabel(entry, false, entryIdx);\n        }\n    }\n\n    /**\n     * Function to change visibility of label and white rectangle inside graph (next to mouse-cursor line).\n     * @param entry {DataEntry} Object containing the dataset.\n     * @param visible {Boolean} Boolean giving information about visibility of a label.\n     */\n    private chVisLabel(entry: InternalDataEntry, visible: boolean, entryIdx: number): void {\n        if (visible) {\n            entry.focusLabel\n                .attr('visibility', 'visible')\n                .attr('class', 'focus-visibility');\n            entry.focusLabelRect\n                .attr('visibility', 'visible')\n                .attr('class', 'focus-visibility');\n        } else {\n            entry.focusLabel\n                .attr('visibility', 'hidden');\n            entry.focusLabelRect\n                .attr('visibility', 'hidden');\n\n            this.labelTimestamp[entryIdx] = null;\n            delete this.highlightOutput.ids[entry.internalId];\n        }\n    }\n\n    /**\n     * Function to show the labeling inside the graph.\n     * @param entry {DataEntry} Object containg the dataset.\n     * @param item {DataEntry} Object of the entry in the dataset.\n     */\n    private showLabelValues(entry: InternalDataEntry, item: DataEntry): void {\n        let id = 1;\n        let onLeftSide: boolean = this.checkLeftSide(item.xDiagCoord);\n        if (entry.focusLabel) {\n            entry.focusLabel.text(item[id] + (entry.axisOptions.uom ? entry.axisOptions.uom : ''));\n            const entryX: number = onLeftSide ?\n                item.xDiagCoord + 4 : item.xDiagCoord - this.getDimensions(entry.focusLabel.node()).w + 4;\n            entry.focusLabel\n                .attr('x', entryX)\n                .attr('y', item.yDiagCoord);\n            entry.focusLabelRect\n                .attr('x', entryX)\n                .attr('y', item.yDiagCoord - this.getDimensions(entry.focusLabel.node()).h + 3)\n                .attr('width', this.getDimensions(entry.focusLabel.node()).w)\n                .attr('height', this.getDimensions(entry.focusLabel.node()).h);\n\n            this.highlightOutput.ids[entry.internalId] = {\n                'timestamp': item[0],\n                'value': item[1]\n            };\n        } else {\n            delete this.highlightOutput.ids[entry.internalId];\n        }\n    }\n\n    /**\n     * Function to show the time labeling inside the graph.\n     * @param item {DataEntry} Object of the entry in the dataset.\n     * @param entryIdx {Number} Number of the index of the entry.\n     */\n    private showTimeIndicatorLabel(item: DataEntry, entryIdx: number, mouseCoord: number): void {\n        // timestamp is the time where the mouse-cursor is\n        this.labelTimestamp[entryIdx] = item[0];\n        this.labelXCoord[entryIdx] = item.xDiagCoord;\n        this.distLabelXCoord[entryIdx] = Math.abs(mouseCoord - item.xDiagCoord);\n        let min = d3.min(this.distLabelXCoord);\n        let idxOfMin = this.distLabelXCoord.findIndex((elem) => elem === min);\n        let onLeftSide = this.checkLeftSide(item.xDiagCoord);\n        let right = this.labelXCoord[idxOfMin] + 2;\n        let left = this.labelXCoord[idxOfMin] - this.getDimensions(this.focuslabelTime.node()).w - 2;\n        this.focuslabelTime.text(moment(this.labelTimestamp[idxOfMin]).format('DD.MM.YY HH:mm'));\n        this.focuslabelTime\n            .attr('x', onLeftSide ? right : left)\n            .attr('y', 13);\n        this.highlightFocus\n            .attr('x1', this.labelXCoord[idxOfMin])\n            .attr('y1', 0)\n            .attr('x2', this.labelXCoord[idxOfMin])\n            .attr('y2', this.height)\n            .classed('hidden', false);\n        this.highlightOutput.timestamp = this.labelTimestamp[idxOfMin];\n    }\n\n    /**\n     * Function giving information if the mouse is on left side of the diagram.\n     * @param itemCoord {number} x coordinate of the value (e.g. mouse) to be checked\n     */\n    private checkLeftSide(itemCoord: number): boolean {\n        return ((this.background.node().getBBox().width + this.bufferSum) / 2 > itemCoord) ? true : false;\n    }\n\n    /**\n     * Function to wrap the text for the y axis label.\n     * @param text {any} y axis label\n     * @param width {Number} width of the axis which must not be crossed\n     * @param xposition {Number} position to center the label in the middle\n     */\n    private wrapText(textObj: any, width: number, xposition: number): void {\n        textObj.each(function (u: any, i: number, d: NodeList) {\n            let text = d3.select(this),\n                words = text.text().split(/\\s+/).reverse(),\n                word,\n                line = [],\n                // lineNumber = 0,\n                lineHeight = (i === d.length - 1 ? 0.3 : 1.1), // ems\n                y = text.attr('y'),\n                dy = parseFloat(text.attr('dy')),\n                tspan = text.text(null).append('tspan').attr('x', 0 - xposition).attr('y', y).attr('dy', dy + 'em');\n            while (word = words.pop()) {\n                line.push(word);\n                tspan.text(line.join(' '));\n                let node: SVGTSpanElement = <SVGTSpanElement>tspan.node();\n                let hasGreaterWidth: boolean = node.getComputedTextLength() > width;\n                if (hasGreaterWidth) {\n                    line.pop();\n                    tspan.text(line.join(' '));\n                    line = [word];\n                    tspan = text.append('tspan').attr('x', 0 - xposition).attr('y', y).attr('dy', lineHeight + dy + 'em').text(word);\n                }\n            }\n        });\n    }\n\n    /**\n     * Function that returns the boundings of a html element.\n     * @param el {Object} Object of the html element.\n     */\n    private getDimensions(el: any): { w: number, h: number } {\n        let w = 0;\n        let h = 0;\n        if (el) {\n            const dimensions = el.getBBox();\n            w = dimensions.width;\n            h = dimensions.height;\n        } else {\n            console.log('error: getDimensions() ' + el + ' not found.');\n        }\n        return {\n            w,\n            h\n        };\n    }\n\n    /**\n     * Function to generate uuid for a diagram\n     */\n    private uuidv4(): string {\n        return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4();\n    }\n\n    /**\n     * Function to generate components of the uuid for a diagram\n     */\n    private s4(): string {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n\n    /**\n     * Function that logs the error in the console.\n     * @param error {Object} Object with the error.\n     */\n    private onError(error: any): void {\n        console.error(error);\n    }\n\n}\n","export enum D3AxisType {\n    Distance,\n    Time,\n    Ticks\n}\n","import {\n    AfterViewInit,\n    Component,\n    ElementRef,\n    EventEmitter,\n    Input,\n    IterableDiffers,\n    OnChanges,\n    Output,\n    SimpleChanges,\n    ViewChild,\n    ViewEncapsulation,\n} from '@angular/core';\nimport {\n    DatasetApiInterface,\n    DatasetOptions,\n    DatasetPresenterComponent,\n    IDataset,\n    InternalIdHandler,\n    LocatedTimeValueEntry,\n    Time,\n} from '@helgoland/core';\nimport { LangChangeEvent, TranslateService } from '@ngx-translate/core';\nimport {\n    area,\n    axisBottom,\n    axisLeft,\n    axisRight,\n    axisTop,\n    bisector,\n    curveLinear,\n    extent,\n    line,\n    mouse,\n    ScaleLinear,\n    scaleLinear,\n    select,\n    timeFormat,\n} from 'd3';\nimport moment from 'moment';\n\nimport { D3AxisType } from '../model/d3-axis-type';\nimport { D3GraphOptions } from '../model/d3-graph-options';\nimport { D3SelectionRange } from '../model/d3-selection-range';\n\ninterface DataEntry extends LocatedTimeValueEntry {\n    dist: number;\n    tick: number;\n    x: number;\n    y: number;\n    xDiagCoord?: number;\n    [id: string]: any;\n}\n\ninterface DatasetConstellation {\n    dataset?: IDataset;\n    data?: LocatedTimeValueEntry[];\n    yScale?: ScaleLinear<number, number>;\n    drawOptions?: DrawOptions;\n    focusLabelRect?: any;\n    focusLabel?: any;\n}\n\ninterface DrawOptions {\n    uom: string;\n    id: string;\n    color: string;\n    first: boolean;\n    offset: number;\n}\n\n@Component({\n    selector: 'n52-d3-trajectory-graph',\n    template: `<div class=\"d3\" #dthree></div>`,\n    styles: [`.d3{height:100%}.d3 .axis line,.d3 .axis path{fill:none;stroke:#000}.d3 text{font-size:14px}.d3 .graphArea{fill:#b0c4de;fill-opacity:.7}.d3 .grid .tick line{stroke:#d3d3d3;stroke-opacity:.7;shape-rendering:crispEdges}.d3 .map-highlight-label{fill:#fff;fill-opacity:.7}.d3 .mouse-focus-line{pointer-events:none;stroke-width:1px;stroke:#000}.d3 .mouse-drag{fill:rgba(0,0,255,.4);pointer-events:all;cursor:move}`],\n    encapsulation: ViewEncapsulation.None\n})\nexport class D3TrajectoryGraphComponent\n    extends DatasetPresenterComponent<DatasetOptions, D3GraphOptions>\n    implements AfterViewInit, OnChanges {\n\n    @Input()\n    public selection: D3SelectionRange;\n\n    @Output()\n    public onSelectionChangedFinished: EventEmitter<D3SelectionRange> = new EventEmitter();\n\n    @Output()\n    public onSelectionChanged: EventEmitter<D3SelectionRange> = new EventEmitter();\n\n    @Output()\n    public onHoverHighlight: EventEmitter<number> = new EventEmitter();\n\n    @ViewChild('dthree')\n    public d3Elem: ElementRef;\n\n    private datasetMap: Map<string, DatasetConstellation> = new Map();\n    private rawSvg: any;\n    private graph: any;\n    private height: number;\n    private width: number;\n    private margin = {\n        top: 10,\n        right: 10,\n        bottom: 40,\n        left: 40\n    };\n    private maxLabelwidth = 0;\n    private lineFun: d3.Line<DataEntry>;\n    private area: d3.Area<DataEntry>;\n    private xScaleBase: d3.ScaleLinear<number, number>;\n    private yScaleBase: d3.ScaleLinear<number, number>;\n    private background: any;\n    private focusG: any;\n    private highlightFocus: any;\n    private focuslabelTime: any;\n    private focuslabelY: any;\n    private yAxisGen: d3.Axis<number | { valueOf(): number; }>;\n    private baseValues: DataEntry[] = [];\n    private dragging: boolean;\n    private dragStart: [number, number];\n    private dragCurrent: [number, number];\n    private dragRect: any;\n    private dragRectG: any;\n    private bufferSum: number;\n    private dataLength: number;\n\n    private defaultGraphOptions: D3GraphOptions = {\n        axisType: D3AxisType.Distance,\n        dotted: false\n    };\n\n    constructor(\n        protected iterableDiffers: IterableDiffers,\n        protected api: DatasetApiInterface,\n        protected datasetIdResolver: InternalIdHandler,\n        protected timeSrvc: Time,\n        protected translateService: TranslateService\n    ) {\n        super(iterableDiffers, api, datasetIdResolver, timeSrvc, translateService);\n        this.presenterOptions = this.defaultGraphOptions;\n    }\n\n    public ngOnChanges(changes: SimpleChanges) {\n        super.ngOnChanges(changes);\n        if (changes.selection && this.selection) {\n            this.processAllData();\n            this.drawLineGraph();\n        }\n    }\n\n    public ngAfterViewInit(): void {\n        this.rawSvg = select(this.d3Elem.nativeElement)\n            .append('svg')\n            .attr('width', '100%')\n            .attr('height', '100%');\n\n        this.graph = this.rawSvg\n            .append('g')\n            .attr('transform', 'translate(' + (this.margin.left + this.maxLabelwidth) + ',' + this.margin.top + ')');\n\n        this.lineFun = line<DataEntry>()\n            .x(this.calcXValue)\n            .y(this.calcYValue)\n            .curve(curveLinear);\n\n        this.area = area<DataEntry>()\n            .x(this.calcXValue)\n            .y0(this.height)\n            .y1(this.calcYValue)\n            .curve(curveLinear);\n\n        this.drawLineGraph();\n    }\n\n    public reloadDataForDatasets(datasetIds: string[]): void {\n        console.log('reload data at ' + new Date());\n    }\n\n    protected onLanguageChanged(langChangeEvent: LangChangeEvent): void { }\n\n    protected timeIntervalChanges(): void {\n        this.datasetMap.forEach((entry) => {\n            if (entry.dataset) {\n                this.loadData(entry.dataset);\n            }\n        });\n    }\n\n    protected addDataset(id: string, url: string): void {\n        this.api.getDataset(id, url).subscribe((dataset) => {\n            this.datasetMap.set(dataset.internalId, { dataset });\n            this.loadData(dataset);\n        });\n    }\n\n    protected removeDataset(internalId: string): void {\n        this.datasetMap.delete(internalId);\n        this.processAllData();\n        this.drawLineGraph();\n    }\n\n    protected setSelectedId(internalId: string): void {\n        throw new Error('Method not implemented.');\n    }\n\n    protected removeSelectedId(internalId: string): void {\n        throw new Error('Method not implemented.');\n    }\n\n    protected presenterOptionsChanged(options: D3GraphOptions): void {\n        this.timeIntervalChanges();\n    }\n\n    protected datasetOptionsChanged(internalId: string, options: DatasetOptions, firstChange: boolean): void {\n        if (!firstChange && this.datasetMap.has(internalId)) {\n            this.loadData(this.datasetMap.get(internalId).dataset);\n        }\n    }\n\n    protected onResize(): void {\n        this.drawLineGraph();\n    }\n\n    private loadData(dataset: IDataset) {\n        if (this.timespan &&\n            this.datasetOptions.has(dataset.internalId) &&\n            this.datasetOptions.get(dataset.internalId).visible) {\n            const buffer = this.timeSrvc.getBufferedTimespan(this.timespan, 0.2);\n            const option = this.datasetOptions.get(dataset.internalId);\n            this.api.getData<LocatedTimeValueEntry>(dataset.id, dataset.url, buffer,\n                {\n                    generalize: option.generalize\n                })\n                .subscribe((result) => {\n                    this.dataLength = result.values.length;\n                    this.datasetMap.get(dataset.internalId).data = result.values;\n                    this.processDataForId(dataset.internalId);\n                    this.drawLineGraph();\n                });\n        } else {\n            this.drawLineGraph();\n        }\n    }\n\n    private processAllData() {\n        this.baseValues = [];\n        this.datasetIds.forEach((id) => this.processDataForId(id));\n    }\n\n    private processDataForId(internalId: string) {\n        if (this.datasetOptions.get(internalId).visible) {\n            const datasetEntry = this.datasetMap.get(internalId);\n            const firstEntry = this.baseValues.length === 0;\n            let previous: DataEntry = null;\n            datasetEntry.data.forEach((elem, idx) => {\n                if (firstEntry) {\n                    const entry = this.createDataEntry(internalId, elem, previous, idx);\n                    if (this.selection) {\n                        if (idx >= this.selection.from && idx <= this.selection.to) {\n                            this.baseValues.push(entry);\n                        }\n                    } else {\n                        this.baseValues.push(entry);\n                    }\n                    previous = entry;\n                } else {\n                    if (this.selection) {\n                        if (idx >= this.selection.from && idx <= this.selection.to) {\n                            if (this.baseValues[idx - this.selection.from]) {\n                                this.baseValues[idx - this.selection.from][internalId] = elem.value;\n                            }\n                        }\n                    } else {\n                        if (this.baseValues[idx]) {\n                            this.baseValues[idx][internalId] = elem.value;\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    private createDataEntry(\n        internalId: string,\n        entry: LocatedTimeValueEntry,\n        previous: DataEntry,\n        index: number\n    ): DataEntry {\n        let dist: number;\n        if (previous) {\n            const newdist = this.distanceBetween(\n                entry.geometry.coordinates[1],\n                entry.geometry.coordinates[0],\n                previous.geometry.coordinates[1],\n                previous.geometry.coordinates[0]\n            );\n            dist = previous.dist + Math.round(newdist / 1000 * 100000) / 100000;\n        } else {\n            dist = 0;\n        }\n        return {\n            tick: index,\n            dist: Math.round(dist * 10) / 10,\n            timestamp: entry.timestamp,\n            value: entry.value,\n            [internalId]: entry.value,\n            x: entry.geometry.coordinates[0],\n            y: entry.geometry.coordinates[1],\n            geometry: entry.geometry\n        };\n    }\n\n    private distanceBetween(latitude1, longitude1, latitude2, longitude2): number {\n        const R = 6371000;\n        const rad = Math.PI / 180;\n        const lat1 = latitude1 * rad;\n        const lat2 = latitude2 * rad;\n        const sinDLat = Math.sin((latitude2 - latitude1) * rad / 2);\n        const sinDLon = Math.sin((longitude2 - longitude1) * rad / 2);\n        const a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon;\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    private calcYValue = (d: DataEntry) => {\n        return this.yScaleBase(d.value);\n    }\n\n    private calcXValue = (d: DataEntry, i: number) => {\n        const xDiagCoord = this.xScaleBase(this.getXValue(d));\n        d.xDiagCoord = xDiagCoord;\n        return xDiagCoord;\n    }\n\n    private calculateHeight(): number {\n        return this.rawSvg.node().height.baseVal.value - this.margin.top - this.margin.bottom;\n    }\n\n    private calculateWidth(): number {\n        return this.rawSvg.node().width.baseVal.value - this.margin.left - this.margin.right - this.maxLabelwidth;\n    }\n\n    private getXValue(data: DataEntry) {\n        switch (this.presenterOptions.axisType) {\n            case D3AxisType.Distance:\n                return data.dist;\n            case D3AxisType.Time:\n                return data.timestamp;\n            case D3AxisType.Ticks:\n                return data.tick;\n            default:\n                return data.tick;\n        }\n    }\n\n    private drawDots(values: DataEntry[], yScale: d3.ScaleLinear<number, number>, options: DrawOptions) {\n        this.graph.selectAll('dot')\n            .data(values)\n            .enter().append('circle')\n            .attr('stroke', options.color)\n            .attr('r', 1.5)\n            .attr('fill', options.color)\n            .attr('cx', this.calcXValue)\n            .attr('cy', (d: DataEntry) => yScale(d[options.id]));\n    }\n\n    private drawValueLine(values: DataEntry[], yScale: d3.ScaleLinear<number, number>, options: DrawOptions) {\n        this.graph.append('svg:path')\n            .datum(values)\n            .attr('class', 'line')\n            .attr('fill', 'none')\n            .attr('stroke', options.color)\n            .attr('stroke-width', 1)\n            .attr('d', line<DataEntry>()\n                .x(this.calcXValue)\n                .y((d: DataEntry) => yScale(d[options.id]))\n                .curve(curveLinear));\n    }\n\n    private drawGraph(yScale: d3.ScaleLinear<number, number>, options: DrawOptions) {\n        if (this.presenterOptions.dotted) {\n            this.drawDots(this.baseValues, yScale, options);\n        } else {\n            this.drawValueLine(this.baseValues, yScale, options);\n        }\n    }\n\n    private drawLineGraph() {\n        if (!this.baseValues || this.baseValues.length === 0 || !this.graph) {\n            return;\n        }\n\n        this.height = this.calculateHeight();\n        this.width = this.calculateWidth();\n\n        this.graph.selectAll('*').remove();\n\n        this.bufferSum = 0;\n\n        this.yScaleBase = null;\n\n        this.datasetMap.forEach((datasetEntry, id) => {\n            if (this.datasetOptions.has(id) && datasetEntry.data && this.datasetOptions.get(id).visible) {\n                datasetEntry.drawOptions = {\n                    uom: datasetEntry.dataset.uom,\n                    id: datasetEntry.dataset.internalId,\n                    color: this.datasetOptions.get(id).color,\n                    first: this.yScaleBase === null,\n                    offset: this.bufferSum\n                };\n                const axisResult = this.drawYAxis(datasetEntry.drawOptions);\n                if (this.yScaleBase === null) {\n                    this.yScaleBase = axisResult.yScale;\n                } else {\n                    this.bufferSum = axisResult.buffer;\n                }\n                datasetEntry.yScale = axisResult.yScale;\n            }\n        });\n\n        if (!this.yScaleBase) {\n            return;\n        }\n\n        // draw right axis as border\n        this.graph.append('svg:g')\n            .attr('class', 'y axis')\n            .attr('transform', 'translate(' + this.width + ', 0)')\n            .call(axisRight(this.yScaleBase).tickSize(0).ticks(0));\n\n        this.drawXAxis(this.bufferSum);\n\n        this.datasetMap.forEach((entry, id) => {\n            if (this.datasetOptions.has(id) && this.datasetOptions.get(id).visible && entry.data) {\n                this.drawGraph(entry.yScale, entry.drawOptions);\n            }\n        });\n\n        this.background = this.graph.append('svg:rect')\n            .attr('width', this.width - this.bufferSum)\n            .attr('height', this.height)\n            .attr('fill', 'none')\n            .attr('stroke', 'none')\n            .attr('pointer-events', 'all')\n            .attr('transform', 'translate(' + this.bufferSum + ', 0)')\n            .on('mousemove.focus', this.mousemoveHandler)\n            .on('mouseout.focus', this.mouseoutHandler)\n            .on('mousedown.drag', this.dragStartHandler)\n            .on('mousemove.drag', this.dragHandler)\n            .on('mouseup.drag', this.dragEndHandler);\n\n        this.focusG = this.graph.append('g');\n        this.highlightFocus = this.focusG.append('svg:line')\n            .attr('class', 'mouse-focus-line')\n            .attr('x2', '0')\n            .attr('y2', '0')\n            .attr('x1', '0')\n            .attr('y1', '0')\n            .style('stroke', 'black')\n            .style('stroke-width', '1px');\n\n        this.datasetMap.forEach((entry, id) => {\n            if (this.datasetOptions.has(id) && this.datasetOptions.get(id).visible && entry.data) {\n                entry.focusLabelRect = this.focusG.append('svg:rect')\n                    .style('fill', 'white')\n                    .style('stroke', 'none')\n                    .style('pointer-events', 'none');\n                entry.focusLabel = this.focusG.append('svg:text').attr('class', 'mouse-focus-label-x')\n                    .style('pointer-events', 'none')\n                    .style('fill', this.datasetOptions.get(id).color)\n                    .style('font-weight', 'lighter');\n            }\n        });\n\n        this.focuslabelTime = this.focusG.append('svg:text')\n            .style('pointer-events', 'none')\n            .attr('class', 'mouse-focus-label-x');\n        this.focuslabelY = this.focusG.append('svg:text')\n            .style('pointer-events', 'none')\n            .attr('class', 'mouse-focus-label-y');\n    }\n\n    private mousemoveHandler = () => {\n        if (!this.baseValues || this.baseValues.length === 0) {\n            return;\n        }\n        const coords = mouse(this.background.node());\n        const idx = this.getItemForX(coords[0] + this.bufferSum, this.baseValues);\n        this.showDiagramIndicator(idx);\n        this.onHoverHighlight.emit(this.baseValues[idx].tick);\n    }\n\n    private mouseoutHandler = () => {\n        this.hideDiagramIndicator();\n    }\n\n    private dragStartHandler = () => {\n        this.dragging = false;\n        this.dragStart = mouse(this.background.node());\n    }\n\n    private dragHandler = () => {\n        this.dragging = true;\n        this.drawDragRectangle();\n    }\n\n    private dragEndHandler = () => {\n        if (!this.dragStart || !this.dragging) {\n            this.onSelectionChangedFinished.emit({ from: 0, to: this.dataLength });\n        } else {\n            const from = this.getItemForX(this.dragStart[0] + this.bufferSum, this.baseValues);\n            const to = this.getItemForX(this.dragCurrent[0] + this.bufferSum, this.baseValues);\n            this.onSelectionChangedFinished.emit(this.prepareRange(this.baseValues[from].tick, this.baseValues[to].tick));\n        }\n        this.dragStart = null;\n        this.dragging = false;\n        this.resetDrag();\n    }\n\n    private prepareRange(from: number, to: number): D3SelectionRange {\n        if (from <= to) {\n            return { from, to };\n        }\n        return { from: to, to: from };\n    }\n\n    private drawDragRectangle() {\n        if (!this.dragStart) { return; }\n\n        this.dragCurrent = mouse(this.background.node());\n\n        const from = this.getItemForX(this.dragStart[0] + this.bufferSum, this.baseValues);\n        const to = this.getItemForX(this.dragCurrent[0] + this.bufferSum, this.baseValues);\n        this.onSelectionChanged.emit(this.prepareRange(this.baseValues[from].tick, this.baseValues[to].tick));\n\n        const x1 = Math.min(this.dragStart[0], this.dragCurrent[0]);\n        const x2 = Math.max(this.dragStart[0], this.dragCurrent[0]);\n\n        if (!this.dragRect && !this.dragRectG) {\n\n            this.dragRectG = this.graph.append('g');\n\n            this.dragRect = this.dragRectG.append('rect')\n                .attr('width', x2 - x1)\n                .attr('height', this.height)\n                .attr('x', x1 + this.bufferSum)\n                .attr('class', 'mouse-drag')\n                .style('pointer-events', 'none');\n        } else {\n            this.dragRect.attr('width', x2 - x1)\n                .attr('x', x1 + this.bufferSum);\n        }\n    }\n\n    private resetDrag() {\n        if (this.dragRectG) {\n            this.dragRectG.remove();\n            this.dragRectG = null;\n            this.dragRect = null;\n        }\n    }\n\n    private hideDiagramIndicator() {\n        this.focusG.style('visibility', 'hidden');\n    }\n\n    private showDiagramIndicator = (idx: number) => {\n        const item = this.baseValues[idx];\n        this.focusG.style('visibility', 'visible');\n        this.highlightFocus.attr('x1', item.xDiagCoord)\n            .attr('y1', 0)\n            .attr('x2', item.xDiagCoord)\n            .attr('y2', this.height)\n            .classed('hidden', false);\n\n        let onLeftSide = false;\n        if ((this.background.node().getBBox().width + this.bufferSum) / 2 > item.xDiagCoord) { onLeftSide = true; }\n\n        this.showLabelValues(item, onLeftSide);\n        this.showTimeIndicatorLabel(item, onLeftSide);\n        this.showBottomIndicatorLabel(item, onLeftSide);\n    }\n\n    private showLabelValues(item: DataEntry, onLeftSide: boolean) {\n        this.datasetMap.forEach((entry, id) => {\n            if (this.datasetOptions.get(id).visible) {\n                if (entry.focusLabel) {\n                    entry.focusLabel.text(item[id] + (entry.dataset.uom ? entry.dataset.uom : ''));\n                    const entryX = onLeftSide ?\n                        item.xDiagCoord + 2 : item.xDiagCoord - this.getDimensions(entry.focusLabel.node()).w;\n                    entry.focusLabel\n                        .attr('x', entryX)\n                        .attr('y', entry.yScale(item[id]) + this.getDimensions(entry.focusLabel.node()).h - 3);\n                    entry.focusLabelRect\n                        .attr('x', entryX)\n                        .attr('y', entry.yScale(item[id]))\n                        .attr('width', this.getDimensions(entry.focusLabel.node()).w)\n                        .attr('height', this.getDimensions(entry.focusLabel.node()).h);\n                }\n            }\n        });\n    }\n\n    private showTimeIndicatorLabel(item: DataEntry, onLeftSide: boolean) {\n        this.focuslabelTime.text(moment(item.timestamp).format('DD.MM.YY HH:mm'));\n        this.focuslabelTime\n            .attr('x', onLeftSide ? item.xDiagCoord + 2 : item.xDiagCoord - this.getDimensions(this.focuslabelTime.node()).w)\n            .attr('y', 13);\n    }\n\n    private showBottomIndicatorLabel(item: DataEntry, onLeftSide: boolean) {\n        if (this.presenterOptions.axisType === D3AxisType.Distance) {\n            this.focuslabelY.text(item.dist + ' km');\n        }\n        if (this.presenterOptions.axisType === D3AxisType.Ticks) {\n            this.focuslabelY.text('Measurement: ' + item.tick);\n        }\n        this.focuslabelY\n            .attr('y', this.calculateHeight() - 5)\n            .attr('x', onLeftSide ? item.xDiagCoord + 2 : item.xDiagCoord - this.getDimensions(this.focuslabelY.node()).w);\n    }\n\n    private getDimensions(el: any) {\n        let w = 0;\n        let h = 0;\n        if (el) {\n            const dimensions = el.getBBox();\n            w = dimensions.width;\n            h = dimensions.height;\n        } else {\n            console.log('error: getDimensions() ' + el + ' not found.');\n        }\n        return {\n            w,\n            h\n        };\n    }\n\n    private getItemForX(x: number, data: DataEntry[]) {\n        const index = this.xScaleBase.invert(x);\n        const bisectDate = bisector((d: DataEntry) => {\n            switch (this.presenterOptions.axisType) {\n                case D3AxisType.Distance:\n                    return d.dist;\n                case D3AxisType.Time:\n                    return d.timestamp;\n                case D3AxisType.Ticks:\n                default:\n                    return d.tick;\n            }\n        }).left;\n        return bisectDate(this.baseValues, index);\n    }\n\n    private drawYAxis(options: DrawOptions): any {\n        const range = extent<DataEntry, number>(this.baseValues, (datum, index, array) => {\n            return datum[options.id]; // here with ID\n        });\n        const rangeOffset = (range[1] - range[0]) * 0.10;\n        const yScale = scaleLinear()\n            .domain([range[0] - rangeOffset, range[1] + rangeOffset])\n            .range([this.height, 0]);\n\n        this.yAxisGen = axisLeft(yScale).ticks(5);\n\n        // draw y axis\n        const axis = this.graph.append('svg:g')\n            .attr('class', 'y axis')\n            .call(this.yAxisGen);\n\n        // draw y axis label\n        const text = this.graph.append('text')\n            .attr('transform', 'rotate(-90)')\n            .attr('dy', '1em')\n            .style('text-anchor', 'middle')\n            .style('fill', options.color)\n            .text(options.uom);\n\n        const axisWidth = axis.node().getBBox().width + 5 + this.getDimensions(text.node()).h;\n        const buffer = options.offset + (axisWidth < 30 ? 30 : axisWidth);\n        if (!options.first) {\n            axis.attr('transform', 'translate(' + buffer + ', 0)');\n        }\n\n        const textOffset = !options.first ? buffer : options.offset;\n        text.attr('y', 0 - this.margin.left - this.maxLabelwidth + textOffset)\n            .attr('x', 0 - (this.height / 2));\n\n        // draw the y grid lines when there is only one dataset\n        if (this.datasetIds.length === 1) {\n            this.graph.append('svg:g')\n                .attr('class', 'grid')\n                .call(axisLeft(yScale)\n                    .ticks(5)\n                    .tickSize(-this.width)\n                    .tickFormat(() => '')\n                );\n        }\n\n        return {\n            buffer,\n            yScale\n        };\n    }\n\n    private drawXAxis(buffer: number) {\n        this.xScaleBase = scaleLinear()\n            .domain(this.getXDomain(this.baseValues))\n            .range([buffer, this.width]);\n\n        const xAxisGen = axisBottom(this.xScaleBase).ticks(5);\n\n        if (this.presenterOptions.axisType === D3AxisType.Time) {\n            xAxisGen.tickFormat((d) => {\n                return timeFormat('%d.%m.%Y %H:%M:%S')(new Date(d.valueOf()));\n            });\n        }\n\n        // draw x axis\n        this.graph.append('svg:g')\n            .attr('class', 'x axis')\n            .attr('transform', 'translate(0,' + this.height + ')')\n            .call(xAxisGen);\n\n        // draw the x grid lines\n        this.graph.append('svg:g')\n            .attr('class', 'grid')\n            .attr('transform', 'translate(0,' + this.height + ')')\n            .call(axisBottom(this.xScaleBase)\n                .ticks(10)\n                .tickSize(-this.height)\n                .tickFormat(() => '')\n            );\n\n        // draw upper axis as border\n        this.graph.append('svg:g')\n            .attr('class', 'x axis')\n            .call(axisTop(this.xScaleBase).ticks(0).tickSize(0));\n\n        // text label for the x axis\n        this.graph.append('text')\n            .attr('x', (this.width + buffer) / 2)\n            .attr('y', this.height + this.margin.bottom - 5)\n            .style('text-anchor', 'middle')\n            .text(this.getXAxisLabel());\n    }\n\n    private getXDomain(values: DataEntry[]) {\n        switch (this.presenterOptions.axisType) {\n            case D3AxisType.Distance:\n                return [values[0].dist, values[values.length - 1].dist];\n            case D3AxisType.Time:\n                return [values[0].timestamp, values[values.length - 1].timestamp];\n            default:\n                return [values[0].tick, values[values.length - 1].tick];\n        }\n    }\n\n    private getXAxisLabel() {\n        switch (this.presenterOptions.axisType) {\n            case D3AxisType.Distance:\n                return 'Distance';\n            case D3AxisType.Time:\n                return 'Time';\n            default:\n                return 'Ticks';\n        }\n    }\n\n}\n","import {\n  AfterViewInit,\n  Component,\n  Input,\n  IterableDiffers,\n  OnChanges,\n  SimpleChanges,\n  ViewEncapsulation,\n} from '@angular/core';\nimport { ColorService, DatasetApiInterface, DatasetOptions, InternalIdHandler, MinMaxRange, Time } from '@helgoland/core';\nimport { TranslateService } from '@ngx-translate/core';\nimport { extent } from 'd3';\n\nimport {\n  D3TimeseriesGraphComponent,\n  DataEntry,\n  InternalDataEntry,\n} from '../d3-timeseries-graph/d3-timeseries-graph.component';\nimport { D3TimeFormatLocaleService } from '../helper/d3-time-format-locale.service';\n\n/**\n * Additional Data which can be add to the component {@link ExtendedDataD3TimeseriesGraphComponent} as Input.\n * One of the optional properties 'linkedDatasetId' and 'yaxisLabel' is mandatory.\n */\nexport interface AdditionalData {\n  /**\n   * Linked to an existing dataset in the graph component and uses it dataset options if no other datasetoptions are presented.\n   */\n  linkedDatasetId?: string;\n  /**\n   * Y-Axis label if no link to an existing dataset is given.\n   */\n  yaxisLabel?: string;\n  /**\n   * The dataset options, which describes the styling of the additional data.\n   */\n  datasetOptions?: DatasetOptions;\n  /**\n   * The additional data arrey with tupels of timestamp and value.\n   */\n  data: AdditionalDataEntry[];\n}\n\n/**\n * Additional data entry tuple\n */\nexport interface AdditionalDataEntry {\n  timestamp: number;\n  value: number;\n}\n\n/**\n * Extends the common d3 component, with the ability to add additional data to the graph. To set or change  additional data, allways sets the complete array of data new. The componet just redraws if\n * the array is reset.\n */\n@Component({\n  selector: 'n52-extended-data-d3-timeseries-graph',\n  template: `<div class=\"d3\" #d3timeseries></div>\n`,\n  styles: [`.d3{height:100%;width:100%;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.d3 .grid .tick line{stroke:#d3d3d3;stroke-opacity:.7;shape-rendering:crispEdges}.d3 .graphDots{stroke-width:0;stroke-opacity:1}.d3 .graphDots .hover{stroke-width:20px;stroke-opacity:.5}.d3 .formerButton,.d3 .laterButton{fill:grey;opacity:.3}.d3 .formerButton:hover,.d3 .laterButton:hover{opacity:.6}.d3 .arrow{stroke:grey;stroke-width:3px}`],\n  encapsulation: ViewEncapsulation.None\n})\nexport class ExtendedDataD3TimeseriesGraphComponent extends D3TimeseriesGraphComponent implements OnChanges, AfterViewInit {\n\n  @Input()\n  public additionalData: AdditionalData[] = [];\n\n  private additionalPreparedData: InternalDataEntry[] = [];\n\n  constructor(\n    protected iterableDiffers: IterableDiffers,\n    protected api: DatasetApiInterface,\n    protected datasetIdResolver: InternalIdHandler,\n    protected timeSrvc: Time,\n    protected timeFormatLocaleService: D3TimeFormatLocaleService,\n    protected colorService: ColorService,\n    protected translateService: TranslateService\n  ) {\n    super(iterableDiffers, api, datasetIdResolver, timeSrvc, timeFormatLocaleService, colorService, translateService);\n  }\n\n  public ngOnChanges(changes: SimpleChanges) {\n    super.ngOnChanges(changes);\n    if (changes.additionalData && this.additionalData && this.graph) {\n      this.clearAdditionalData();\n      this.plotGraph();\n    }\n  }\n\n  protected plotGraph() {\n    this.prepareAdditionalData();\n    super.plotGraph();\n  }\n\n  public ngAfterViewInit(): void {\n    super.ngAfterViewInit();\n    if (this.additionalData) {\n      setTimeout(() => this.plotGraph(), 0);\n    }\n  }\n\n  private clearAdditionalData() {\n    this.additionalPreparedData.forEach(data => {\n      this.yRangesEachUom.forEach(e => {\n        const idx = e.ids.indexOf(data.internalId);\n        if (idx > -1) { e.ids.splice(idx, 1); }\n      });\n    });\n\n    if (this.yRangesEachUom) {\n      for (let i = this.yRangesEachUom.length - 1; i >= 0; i--) {\n        const element = this.yRangesEachUom[i];\n        if (element.ids.length === 0) {\n          this.yRangesEachUom.splice(i, 1);\n        }\n      }\n    }\n\n    this.additionalPreparedData = [];\n  }\n\n  private prepareAdditionalData() {\n    if (this.additionalData) {\n      this.additionalData.forEach(entry => {\n        if ((entry.linkedDatasetId || entry.yaxisLabel) && entry.data) {\n\n          if (entry.data.length > 0) {\n            let options = entry.datasetOptions || this.datasetOptions.get(entry.linkedDatasetId);\n            let dataset = this.datasetMap.get(entry.linkedDatasetId);\n            const prepDataIdx = this.additionalPreparedData.findIndex(e => e.internalId.startsWith(entry.linkedDatasetId) || e.internalId === entry.yaxisLabel);\n            let dataEntry: InternalDataEntry;\n            if (prepDataIdx === -1) {\n              dataEntry = {\n                internalId: entry.linkedDatasetId ? entry.linkedDatasetId + 'add' : entry.yaxisLabel,\n                id: -1,\n                color: options.color,\n                data: options.visible ? entry.data.map(e => {\n                  return {\n                    timestamp: e.timestamp,\n                    value: e.value\n                  };\n                }) : [],\n                points: {\n                  fillColor: options.color\n                },\n                lines: {\n                  lineWidth: options.lineWidth,\n                  pointRadius: options.pointRadius\n                },\n                bars: {\n                  lineWidth: options.lineWidth\n                },\n                axisOptions: {\n                  uom: dataset ? dataset.uom : entry.yaxisLabel,\n                  label: dataset ? dataset.label : entry.yaxisLabel,\n                  zeroBased: options.zeroBasedYAxis,\n                  yAxisRange: options.yAxisRange,\n                  autoRangeSelection: options.autoRangeSelection,\n                  separateYAxis: options.separateYAxis\n                },\n                visible: options.visible\n              };\n              if (dataset) {\n                dataEntry.axisOptions.parameters = {\n                  feature: dataset.parameters.feature,\n                  phenomenon: dataset.parameters.phenomenon,\n                  offering: dataset.parameters.offering\n                };\n              }\n              this.additionalPreparedData.push(dataEntry);\n            } else {\n              dataEntry = this.additionalPreparedData[prepDataIdx];\n              dataEntry.axisOptions.uom = dataset ? dataset.uom : entry.yaxisLabel;\n              dataEntry.axisOptions.label = dataset ? dataset.label : entry.yaxisLabel;\n            }\n\n            const newDatasetIdx = this.yRangesEachUom.findIndex((e) => e.ids.indexOf(entry.linkedDatasetId) > -1);\n            const dataExtent = extent<DataEntry, number>(dataEntry.data, (d) => {\n              if (this.timespan.from <= d.timestamp && this.timespan.to >= d.timestamp) { return d.value; }\n            });\n            if (isFinite(dataExtent[0]) && isFinite(dataExtent[1])) {\n              const range: MinMaxRange = { min: dataExtent[0], max: dataExtent[1] };\n              this.extendRange(range);\n              if (newDatasetIdx === -1) {\n                const existingAxisIndex = this.yRangesEachUom.findIndex(e => e.ids.indexOf(entry.yaxisLabel) !== -1);\n                const axisRange = {\n                  uom: entry.yaxisLabel,\n                  range: range,\n                  autoRange: options.autoRangeSelection,\n                  preRange: range,\n                  originRange: range,\n                  zeroBased: options.zeroBasedYAxis,\n                  outOfrange: false,\n                  ids: [entry.yaxisLabel],\n                  parameters: dataEntry.axisOptions.parameters\n                };\n                if (existingAxisIndex > -1) {\n                  this.yRangesEachUom[existingAxisIndex] = axisRange;\n                } else {\n                  this.yRangesEachUom.push(axisRange);\n                }\n              } else {\n                if (this.yRangesEachUom[newDatasetIdx].range) {\n                  this.yRangesEachUom[newDatasetIdx].range.min = Math.min(range.min, this.yRangesEachUom[newDatasetIdx].range.min);\n                  this.yRangesEachUom[newDatasetIdx].range.max = Math.max(range.max, this.yRangesEachUom[newDatasetIdx].range.max);\n                } else {\n                  this.yRangesEachUom[newDatasetIdx].range = range;\n                }\n                this.yRangesEachUom[newDatasetIdx].ids.push(entry.linkedDatasetId ? entry.linkedDatasetId + 'add' : entry.yaxisLabel);\n              }\n              if (entry.yaxisLabel && !entry.linkedDatasetId) {\n                let idx = this.listOfUoms.indexOf(entry.yaxisLabel);\n                if (idx < 0) { this.listOfUoms.push(entry.yaxisLabel); }\n              }\n            }\n          }\n        } else {\n          console.warn('Please check the additional entry, it needs at least a \\'linkedDatasetId\\' or a \\'yaxisLabel\\' property and a \\'data\\' property: ', entry);\n        }\n      });\n    }\n  }\n\n  protected drawAllGraphLines() {\n    super.drawAllGraphLines();\n    this.additionalPreparedData.forEach(e => this.drawGraphLine(e));\n  }\n\n}\n","import {\n    AfterViewInit,\n    Component,\n    ElementRef,\n    Input,\n    OnChanges,\n    ViewChild\n} from '@angular/core';\nimport * as d3 from 'd3';\nimport {\n    D3GeneralDataPoint,\n    D3GeneralDataset,\n    D3GeneralInput,\n    D3GeneralPlotOptions,\n    D3GeneralAxisOptions,\n    Range,\n    D3GeneralGraphOptions\n} from '../model/d3-general';\nimport { D3TimeFormatLocaleService } from '../helper/d3-time-format-locale.service';\nimport moment from 'moment';\n\n@Component({\n    selector: 'n52-d3-general-graph',\n    template: `<div class=\"d3\" #d3general></div>\n`,\n    styles: [`.d3{height:100%;width:100%;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.d3 .grid .tick line{stroke:#d3d3d3;stroke-opacity:.7;shape-rendering:crispEdges}.d3 .x{fill:orange;fill-opacity:.4}.d3 .x .tick{stroke:#00f;stroke-width:10px}.d3 .x .tick line{stroke:red;stroke-width:15px}.d3 .axis{fill:orange;fill-opacity:.4}.d3 .axis .tick{stroke:#00f;stroke-width:10px}.d3 .axis .tick line{stroke:#ffa07a;stroke-width:15px}.d3 .graphDots{stroke-width:0;stroke-opacity:1}.d3 .graphDots .hover{stroke-width:20px;stroke-opacity:.5}`]\n})\nexport class D3GeneralGraphComponent implements AfterViewInit, OnChanges {\n\n    @ViewChild('d3general')\n    public d3Elem: ElementRef;\n\n    @Input()\n    public generalD3Input: D3GeneralInput;\n\n    // componennt data variables\n    private generalData: D3GeneralDataset[] = [];\n    private axisOptions: D3GeneralAxisOptions = {};\n    private plotOptions: D3GeneralPlotOptions = {\n        xlabel: 'x',\n        ylabel: 'y',\n        date: false\n    };\n\n    private defaultGraphOptions: D3GeneralGraphOptions = {\n        color: 'red',\n        lines: {\n            lineWidth: 2,\n            pointRadius: 2\n        }\n    };\n\n    // graph components\n    private rawSvg: any;\n    private graph: any;\n    private graphBody: any;\n    private background: any;\n    private graphFocus: any;\n    private focusG: any;\n    private highlightRect: any;\n    private highlightText: any;\n\n    // component settings\n    private height: number;\n    private width: number;\n    private buffer = 0;\n    private maxLabelwidth = 0;\n\n    private margin = {\n        top: 10,\n        right: 10,\n        bottom: 40,\n        left: 10\n    };\n\n    constructor(\n        protected timeFormatLocaleService: D3TimeFormatLocaleService\n    ) { }\n\n    ngAfterViewInit() {\n        this.rawSvg = d3.select(this.d3Elem.nativeElement)\n            .append('svg')\n            .attr('width', '100%')\n            .attr('height', '100%');\n\n        this.graph = this.rawSvg\n            .append('g')\n            .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n        this.graphFocus = this.rawSvg\n            .append('g')\n            .attr('transform', 'translate(' + (this.margin.left + this.maxLabelwidth) + ',' + this.margin.top + ')');\n\n\n        this.prepareData();\n    }\n\n    ngOnChanges(changes) {\n        if (changes.generalD3Input && this.rawSvg) {\n            this.generalD3Input = changes.generalD3Input.currentValue;\n            this.prepareData();\n        }\n    }\n\n    private prepareData() {\n        if (this.generalD3Input) {\n            // add all input dataset into one array (public generalData)\n            let data = [];\n\n            this.generalD3Input.datasets.forEach((ds, index) => {\n                let dataset: D3GeneralDataset = {\n                    data: ds.data,\n                    id: index\n                };\n                data = data.concat(ds.data);\n                this.generalData.push(dataset);\n            });\n\n            this.plotOptions = this.generalD3Input.plotOptions;\n            this.axisOptions.date = true;\n            this.axisOptions.xRange = this.getRange(data, 'x');\n            this.axisOptions.yRange = this.getRange(data, 'y');\n\n            this.plotGraph();\n        }\n    }\n\n    /**\n     * Function to call functions related to plotting a dataset in a graph.\n     */\n    private plotGraph() {\n        this.height = this.calculateHeight();\n        this.width = this.calculateWidth();\n\n        this.axisOptions.yScale = this.drawYaxis(this.plotOptions);\n        this.axisOptions.xScale = this.drawXaxis(this.plotOptions);\n\n        // create background as rectangle providing panning\n        this.background = this.graph.append('svg:rect')\n            .attr('width', this.width - this.buffer)\n            .attr('height', this.height)\n            .attr('id', 'backgroundRect')\n            .attr('fill', 'none')\n            .attr('stroke', 'none')\n            .attr('pointer-events', 'all')\n            .attr('transform', 'translate(' + this.buffer + ', 0)');\n\n\n        this.focusG = this.graphFocus.append('g');\n        this.highlightRect = this.focusG.append('svg:rect');\n        this.highlightText = this.focusG.append('svg:text');\n\n        this.generalData.forEach(dataset => {\n            this.drawGraphLine(dataset);\n        });\n\n        this.createHoveringNet(this.generalData);\n        this.createHoveringNet(this.generalData);\n    }\n\n    /**\n     * Function to draw y axis.\n     * @param dataset {D3GeneralDataset} Object with information about the dataset.\n     */\n    private drawYaxis(options: D3GeneralPlotOptions) {\n\n        // set range offset for y axis scale\n        let yRangeOffset = 10;\n        const yRange = this.axisOptions.yRange;\n        // check for multiple datapoints\n        if (yRange.max !== yRange.min) {\n            yRangeOffset = (yRange.max - yRange.min) * 0.10;\n        } else {\n            yRangeOffset = yRange.min * 0.10;\n        }\n\n        const yScale = d3.scaleLinear()\n            .domain([yRange.min - yRangeOffset, yRange.max + yRangeOffset])\n            .range([this.height, 0]);\n\n        const yAxisGen = d3.axisLeft(yScale).ticks(5);\n\n        // draw y axis\n        const yAxis = this.graph.append('svg:g')\n            .attr('class', 'y axis')\n            .call(yAxisGen);\n\n        // draw y axis label\n        const yAxisLabel = this.graph.append('text')\n            // .attr('transform', 'rotate(-90)')\n            .attr('transform', 'translate(0, ' + this.height / 2 + ')rotate(-90)')\n            .attr('dy', '1em')\n            .attr('class', 'yAxisTextLabel')\n            .style('font', '18px times')\n            .style('text-anchor', 'middle')\n            .style('fill', 'black')\n            .text(options.ylabel);\n\n        // this.graph.selectAll('.yAxisTextLabel')\n        this.buffer = yAxis.node().getBBox().width + 10 + this.getDimensions(yAxisLabel.node()).h;\n\n        yAxis.attr('transform', 'translate(' + this.buffer + ', 0)');\n\n        // draw y grid lines\n        this.graph.append('svg:g')\n            .attr('class', 'grid')\n            .attr('transform', 'translate(' + this.buffer + ', 0)')\n            .call(d3.axisLeft(yScale)\n                .ticks(5)\n                .tickSize(-this.width + this.buffer)\n                .tickFormat(() => '')\n            );\n\n        return yScale;\n    }\n\n    /**\n     * Function to draw x axis.\n     * @param dataset {D3GeneralDataset} Object with information about the dataset.\n     */\n    private drawXaxis(options: D3GeneralPlotOptions) {\n        // set range offset for x axis scale\n        const xRange = this.axisOptions.xRange;\n        // check for multiple datapoints\n        let ticks = 10;\n        let xRangeOffset = (xRange.max - xRange.min) * 0.10;\n        if (xRange.max === xRange.min) {\n            ticks = 5;\n            xRangeOffset = xRange.min * 0.10;\n        }\n\n        const xScale = d3.scaleLinear()\n            .domain([xRange.min - xRangeOffset, xRange.max + xRangeOffset])\n            .range([this.buffer, this.width]);\n\n        const xAxis = d3.axisBottom(xScale)\n            .ticks(ticks)\n            .tickFormat(d => {\n                if (options.date) {\n                    const date = new Date(d.valueOf());\n\n                    const formatMillisecond = '.%L',\n                        formatSecond = ':%S',\n                        formatMinute = '%H:%M',\n                        formatHour = '%H:%M',\n                        formatDay = '%b %d',\n                        formatWeek = '%b %d',\n                        formatMonth = '%B',\n                        formatYear = '%Y';\n\n                    const format = d3.timeSecond(date) < date ? formatMillisecond\n                        : d3.timeMinute(date) < date ? formatSecond\n                            : d3.timeHour(date) < date ? formatMinute\n                                : d3.timeDay(date) < date ? formatHour\n                                    : d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? formatDay : formatWeek)\n                                        : d3.timeYear(date) < date ? formatMonth\n                                            : formatYear;\n                    return this.timeFormatLocaleService.getTimeLocale(format)(new Date(d.valueOf()));\n                } else {\n                    return '' + d.valueOf();\n                }\n            });\n\n        this.graph.append('g')\n            .attr('class', 'x axis')\n            .attr('transform', 'translate(0,' + this.height + ')')\n            .call(xAxis)\n            .selectAll('text')\n            .style('text-anchor', 'middle');\n\n        // draw x grid lines\n        this.graph.append('svg:g')\n            .attr('class', 'grid')\n            .attr('transform', 'translate(0,' + this.height + ')')\n            .call(xAxis\n                .tickSize(-this.height)\n                .tickFormat(() => '')\n            );\n\n        // draw upper axis as border\n        this.graph.append('svg:g')\n            .attr('class', 'x axis')\n            .call(d3.axisTop(xScale)\n                .ticks(0)\n                .tickSize(0));\n\n        // draw x axis label\n        this.graph.append('text')\n            .attr('x', (this.width + this.buffer) / 2)\n            .attr('y', this.height + this.margin.bottom - 5)\n            .style('text-anchor', 'middle')\n            .text(options.xlabel);\n\n        return xScale;\n    }\n\n    /**\n     * Function to draw the line of the graph.\n     * @param dataset {D3GeneralDataset} Object with information about the datset.\n     */\n    private drawGraphLine(dataset: D3GeneralDataset) {\n        // create grah line component\n        this.graphBody = this.graph\n            .append('g')\n            .attr('clip-path', 'url(#' + dataset.id + ')');\n\n        // create line with dataset\n        let graphLine = d3.line<D3GeneralDataPoint>()\n            .defined(d => (!isNaN(d.x) && !isNaN(d.y)))\n            .x((d) => {\n                const xCoord = this.axisOptions.xScale(d.x);\n                if (!isNaN(xCoord)) {\n                    d.xCoord = xCoord;\n                    return xCoord;\n                }\n            })\n            .y((d) => {\n                const yCoord = this.axisOptions.yScale(d.y);\n                if (!isNaN(yCoord)) {\n                    d.yCoord = yCoord;\n                    return yCoord;\n                }\n            })\n            .curve(d3.curveLinear);\n\n        this.graphBody\n            .append('svg:path')\n            .datum(dataset.data)\n            .attr('class', 'line')\n            .attr('fill', 'none')\n            .attr('stroke', this.plotOptions.graph ? this.plotOptions.graph.color : this.defaultGraphOptions.color)\n            .attr('stroke-width', this.plotOptions.graph ? this.plotOptions.graph.lines.lineWidth : this.defaultGraphOptions.lines.lineWidth)\n            .attr('d', graphLine);\n\n        // draw circles around datapoints\n        this.graphBody.selectAll('.graphDots')\n            .data(dataset.data.filter((d) => !isNaN(d.y)))\n            .enter().append('circle')\n            .attr('class', 'graphDots')\n            .attr('id', function (d) {\n                let datasetxCoordSplit = d.xCoord.toString().split('.')[0] + '-' + d.xCoord.toString().split('.')[1];\n                return 'dot-' + datasetxCoordSplit + '-' + dataset.id + '';\n            })\n            .attr('stroke', this.plotOptions.graph ? this.plotOptions.graph.color : this.defaultGraphOptions.color)\n            .attr('fill', this.plotOptions.graph ? this.plotOptions.graph.color : this.defaultGraphOptions.color)\n            .attr('cx', graphLine.x())\n            .attr('cy', graphLine.y())\n            .attr('r', this.plotOptions.graph ? this.plotOptions.graph.lines.pointRadius : this.defaultGraphOptions.lines.pointRadius);\n\n    }\n\n    /**\n     * Function to create a net of polygons overlaying the graphs to divide sections for hovering.\n     * @param inputData {D3GeneralDataset[]} data containing an array with all datapoints and an id for each dataset\n     */\n    private createHoveringNet(inputData): void {\n        let data = inputData.map(function (series, i) {\n            series.data = series.data.map(function (point) {\n                point.series = i;\n                point[0] = point.x;\n                point[1] = point.y;\n                return point;\n            });\n            return series;\n        });\n\n        let x = d3.scaleLinear(),\n            y = d3.scaleLinear();\n\n        let vertices: [number, number][] = d3.merge(data.map(function (cl, lineIndex) {\n            /**\n             * cl = { data: [{0: number, 1: number, series: number, x: number, y: number}, {}, ...], id: number }\n             * point = each point in a dataset\n            */\n            let outputLine = cl.data.map(function (point, pointIndex) {\n                let outputPoint = [x(point.xCoord), y(point.yCoord), lineIndex, pointIndex, point, cl];\n                return outputPoint; // adding series index to point because data is being flattened\n            });\n            return outputLine;\n        }));\n\n        let left = this.buffer, // + this.margin.left,\n            top = this.margin.top,\n            right = this.background.node().getBBox().width + this.buffer, // + this.margin.left,\n            bottom = this.margin.top + this.background.node().getBBox().height;\n\n        // filter dataset - delete all entries that are NaN\n        let verticesFiltered = vertices.filter(d => !isNaN(d[0]) || !isNaN(d[1]));\n        const Diffvoronoi = d3.voronoi()\n            .extent([[left, top], [right, bottom]]);\n        let diffVoronoi2 = Diffvoronoi.polygons(verticesFiltered);\n\n        let wrap = this.rawSvg.selectAll('g.d3line').data([verticesFiltered]);\n        let gEnter = wrap.enter().append('g').attr('class', 'd3line').append('g');\n        gEnter.append('g').attr('class', 'point-paths');\n\n        // to avoid no hovering for only one dataset without interaction the following lines are doubled\n        // this will create the paths, which can be updated later on (by the 'exit().remove()' function calls)\n        let pointPaths = wrap.select('.point-paths').selectAll('path')\n            .data(diffVoronoi2);\n        pointPaths\n            .enter().append('path')\n            .attr('class', function (d, i) {\n                return 'path-' + i;\n            });\n\n        pointPaths = wrap.select('.point-paths').selectAll('path')\n            .data(diffVoronoi2);\n        pointPaths\n            .enter().append('path')\n            .attr('class', function (d, i) {\n                return 'path-' + i;\n            });\n        pointPaths.exit().remove();\n        pointPaths\n            .attr('clip-path', function (d) {\n                if (d !== undefined) {\n                    let datasetxCoordSplit = d.data[4].xCoord.toString().split('.')[0] + '-' + d.data[4].xCoord.toString().split('.')[1];\n                    return 'url(#clip-' + d.data[5].id + '-' + datasetxCoordSplit + ')';\n                }\n            })\n            .attr('d', function (d) {\n                if (d !== undefined) {\n                    return 'M' + d.join(' ') + 'Z';\n                }\n            })\n            .attr('transform', 'translate(' + this.margin.left + ', ' + this.margin.top + ')')\n            .on('mousemove', (d) => {\n                if (d !== undefined) {\n                    let coords = d3.mouse(this.background.node());\n                    let dataset = d.data[4];\n                    let dist = this.calcDistanceHovering(dataset, coords);\n                    let radius = this.plotOptions.graph ? this.plotOptions.graph.lines.pointRadius : this.defaultGraphOptions.lines.pointRadius;\n                    let color = this.plotOptions.graph ? this.plotOptions.graph.color : this.defaultGraphOptions.color;\n                    if (dist <= 8) {\n                        let rectBack = this.background.node().getBBox();\n                        if (coords[0] >= 0 && coords[0] <= rectBack.width && coords[1] >= 0 && coords[1] <= rectBack.height) {\n                            // highlight hovered dot\n                            let datasetxCoordSplit = dataset.xCoord.toString().split('.')[0] + '-' + dataset.xCoord.toString().split('.')[1];\n                            d3.select('#dot-' + datasetxCoordSplit + '-' + d.data[5].id + '')\n                                .attr('opacity', 0.8)\n                                .attr('r', (radius * 2));\n\n                            this.highlightRect\n                                .style('visibility', 'visible');\n                            this.highlightText\n                                .style('visibility', 'visible');\n\n                            // create text for hovering label\n                            let text = this.plotOptions.date ? 'x: ' + moment(dataset.x).format('DD.MM.YY HH:mm') + ' y: ' + dataset.y : 'x: ' + dataset.x + ' y: ' + dataset.y;\n                            let dotLabel = this.highlightText\n                                .text(text)\n                                .attr('class', 'mouseHoverDotLabel')\n                                .style('pointer-events', 'none')\n                                .style('fill', color);\n\n                            let onLeftSide = false;\n                            if ((this.background.node().getBBox().width + this.buffer) / 2 > coords[0]) { onLeftSide = true; }\n\n                            let rectX: number = dataset.xCoord + 15;\n                            let rectY: number = dataset.yCoord;\n                            let rectW: number = this.getDimensions(dotLabel.node()).w + 8;\n                            let rectH: number = this.getDimensions(dotLabel.node()).h; // + 4;\n\n                            if (!onLeftSide) {\n                                rectX = dataset.xCoord - 15 - rectW;\n                                rectY = dataset.yCoord;\n                            }\n\n                            if ((coords[1] + rectH + 4) > this.background.node().getBBox().height) {\n                                // when label below x axis\n                                console.log('Translate label to a higher place. - not yet implemented');\n                            }\n\n                            // create hovering label\n                            let dotRectangle = this.highlightRect\n                                .attr('class', 'mouseHoverDotRect')\n                                .style('fill', 'white')\n                                .style('fill-opacity', 1)\n                                .style('stroke', color)\n                                .style('stroke-width', '1px')\n                                .style('pointer-events', 'none')\n                                .attr('width', rectW)\n                                .attr('height', rectH)\n                                .attr('transform', 'translate(' + rectX + ', ' + rectY + ')');\n\n                            let labelX: number = dataset.xCoord + 4 + 15;\n                            let labelY: number = dataset.yCoord + this.getDimensions(dotRectangle.node()).h - 4;\n\n                            if (!onLeftSide) {\n                                labelX = dataset.xCoord - rectW + 4 - 15;\n                                labelY = dataset.yCoord + this.getDimensions(dotRectangle.node()).h - 4;\n                            }\n\n                            this.highlightText\n                                .attr('transform', 'translate(' + labelX + ', ' + labelY + ')');\n                        }\n                    } else {\n                        // unhighlight hovered dot\n                        let datasetxCoordSplit = dataset.xCoord.toString().split('.')[0] + '-' + dataset.xCoord.toString().split('.')[1];\n                        d3.select('#dot-' + datasetxCoordSplit + '-' + d.data[5].id + '')\n                            .attr('opacity', 1)\n                            .attr('r', radius);\n\n                        // make label invisible\n                        this.highlightRect\n                            .style('visibility', 'hidden');\n                        this.highlightText\n                            .style('visibility', 'hidden');\n                    }\n                }\n            })\n            .on('mouseout', (d) => {\n                if (d !== undefined) {\n                    let dataset = d.data[4];\n                    let radius = this.plotOptions.graph ? this.plotOptions.graph.lines.pointRadius : this.defaultGraphOptions.lines.pointRadius;\n                    // unhighlight hovered dot\n                    let datasetxCoordSplit = dataset.xCoord.toString().split('.')[0] + '-' + dataset.xCoord.toString().split('.')[1];\n                    d3.select('#dot-' + datasetxCoordSplit + '-' + d.data[5].id + '')\n                        .attr('opacity', 1)\n                        .attr('r', radius);\n\n                    // make label invisible\n                    this.highlightRect\n                        .style('visibility', 'hidden');\n                    this.highlightText\n                        .style('visibility', 'hidden');\n                }\n            });\n    }\n\n    /**\n     * Function to calculate distance between mouse and a hovered point.\n     * @param dataset {} Coordinates of the hovered point.\n     * @param coords {} Coordinates of the mouse.\n     */\n    private calcDistanceHovering(dataset: D3GeneralDataPoint, coords: [number, number]): number {\n        let mX = coords[0] + this.buffer,\n            mY = coords[1], // + this.margin.top,\n            pX = dataset.xCoord,\n            pY = dataset.yCoord;\n        // calculate distance between point and mouse when hovering\n        return Math.sqrt(Math.pow((pX - mX), 2) + Math.pow((pY - mY), 2));\n    }\n\n    private getRange(data: D3GeneralDataPoint[], selector: string): Range {\n        // range for axis scale\n        let range: [number, number] = d3.extent(d3.values(data.map((d) => {\n            if ((!isNaN(d.x) && !isNaN(d.y))) {\n                return d[selector];\n            }\n        })));\n        return { min: range[0], max: range[1] };\n    }\n\n    /**\n     * Function that returns the height of the graph diagram.\n     */\n    private calculateHeight(): number {\n        return (this.d3Elem.nativeElement as HTMLElement).clientHeight - this.margin.top - this.margin.bottom;\n    }\n\n    /**\n     * Function that returns the width of the graph diagram.\n     */\n    private calculateWidth(): number {\n        return this.rawSvg.node().width.baseVal.value - this.margin.left - this.margin.right;\n    }\n\n    /**\n     * Function that returns the boundings of a html element.\n     * @param el {Object} Object of the html element.\n     */\n    private getDimensions(el: any): { w: number, h: number } {\n        let w = 0;\n        let h = 0;\n        if (el) {\n            const dimensions = el.getBBox();\n            w = dimensions.width;\n            h = dimensions.height;\n        } else {\n            console.log('error: getDimensions() ' + el + ' not found.');\n        }\n        return {\n            w,\n            h\n        };\n    }\n\n}\n","import { NgModule } from '@angular/core';\nimport { HelgolandCoreModule } from '@helgoland/core';\n\nimport { D3OverviewTimeseriesGraphComponent } from './d3-overview-timeseries-graph/d3-overview-timeseries-graph.component';\nimport { D3TimeseriesGraphComponent } from './d3-timeseries-graph/d3-timeseries-graph.component';\nimport { D3TrajectoryGraphComponent } from './d3-trajectory-graph/d3-trajectory-graph.component';\nimport {\n  ExtendedDataD3TimeseriesGraphComponent,\n} from './extended-data-d3-timeseries-graph/extended-data-d3-timeseries-graph.component';\nimport { D3TimeFormatLocaleService } from './helper/d3-time-format-locale.service';\nimport { D3GeneralGraphComponent } from './d3-general-graph/d3-general-graph.component';\n\n@NgModule({\n  declarations: [\n    D3TrajectoryGraphComponent,\n    D3TimeseriesGraphComponent,\n    D3OverviewTimeseriesGraphComponent,\n    ExtendedDataD3TimeseriesGraphComponent,\n    D3GeneralGraphComponent\n  ],\n  imports: [\n    HelgolandCoreModule\n  ],\n  exports: [\n    D3TrajectoryGraphComponent,\n    D3TimeseriesGraphComponent,\n    D3OverviewTimeseriesGraphComponent,\n    ExtendedDataD3TimeseriesGraphComponent,\n    D3GeneralGraphComponent\n  ],\n  providers: [\n    D3TimeFormatLocaleService\n  ]\n})\nexport class HelgolandD3Module { }\n","export class D3SelectionRange {\n    public from: number;\n    public to: number;\n}\n"]}